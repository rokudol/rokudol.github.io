<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[自定义view---利用贝塞尔曲线绘制的曲线图]]></title>
    <url>%2F%E8%87%AA%E5%AE%9A%E4%B9%89view---%E5%88%A9%E7%94%A8%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF%E7%BB%98%E5%88%B6%E7%9A%84%E6%9B%B2%E7%BA%BF%E5%9B%BE.html</url>
    <content type="text"><![CDATA[直接来看看效果图吧 需求分析从效果图上，我们可以得出以下结论 与传统的曲线图不同，x，y轴比较另类，x轴是下方的“地区一”，“地区二”，y轴可以把上方的具体数字看做y轴，即“82.66“，”88.86“这些数字 曲线覆盖的下方，有渐变色，颜色从曲线画笔颜色到完全透明 有点击效果以及滑动效果 选中某个点后，弹出浮窗，浮窗有阴影 曲线的绘制方法有两种： 利用贝塞尔曲线绘制 使用CornerPathEffect绘制CornerPathEffect可以将各个连接线之间的夹角用更平滑的方式连接，具体用法本篇文章不做叙述，毕竟我选择用贝塞尔曲线，理由很简单，自己计算控制点，可以做出更多的效果，从效果图可以看出，该曲线图用二阶贝塞尔即可完成 那么，先根据效果图来制定下自定义属性 自定义属性 属性名 值 作用 titleText String title的文字 titleBgColor color title栏的背景颜色 titleTextColor color title文字的颜色 titleTextSize sp title文字大小 chartBgColor color 图表的背景颜色 xCoordinateBgColor color x轴背景颜色 lineColor color y轴线的颜色 textDefaultColor color x轴与y轴为选中时的默认颜色 textSelectedColor color x轴与y轴被选中时的颜色 xCoordinateTextSize sp x轴的文字大小 yCoordinateTextSize sp y轴的文字大小 curveColor color 曲线颜色 chartPointDefaultStyle color 曲线表中点的默认样式 chartPointSelectedStyle color 曲线表中点被选中的样式 xCoordinateSpacing dp x轴坐标间的距离 chartMinimumColor color 图表渐变色中最浅的颜色 floatBoxBgColor color 浮窗的背景颜色 制定好自定义属性后，接下来就需要正式开始撸代码实现效果了 具体实现onMeasure一般来说，图表view的宽度始终都是充满整个屏幕的，根据效果图，高度并没有充满屏幕，那么在onMeasure中，我们只需要关心view的高度在wrap模式下，该如何展示，我用了一个比较简单粗暴的方法： 如果高度是wrap模式，那么设定高度为350dp @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { super.onMeasure(widthMeasureSpec, heightMeasureSpec); int widthSize = MeasureSpec.getSize(widthMeasureSpec); int heightMode = MeasureSpec.getMode(heightMeasureSpec); int heightSize = MeasureSpec.getSize(heightMeasureSpec); //宽度始终为match，只考虑高为自适应的情况 if (heightMode == MeasureSpec.AT_MOST) { heightSize = dip2px(350); } height = heightSize; setMeasuredDimension(widthSize, height); x = firstSpacing; //减去0.1f是因为最后一个X周刻度距离右边的长度为X轴可见长度的10% minX = getWidth() - (getWidth() * 0.1f) - xCoordinateSpacing * (xCoordinateData.size() - 1); maxX = x; } onDraw在开始写onDraw方法前，我们先制定一些小目标： 绘制title 绘制x轴 绘制y轴 绘制图表 绘制数据点 绘制曲线及渐变色 绘制浮窗 绘制title首先，我们要计算title的高度，根据效果图的标注，我们将title部分的高度设置为view高度的1/8 //绘制title private void drawTitle(Canvas canvas) { bgColorPaint.setColor(titleBgColor); int titleBottom = height / 8; canvas.drawRect(0, 0, getWidth(), titleBottom, bgColorPaint); Rect mTextBound = new Rect(); titlePaint.getTextBounds(titleText, 0, titleText.length(), mTextBound); Paint.FontMetrics fontMetrics = titlePaint.getFontMetrics(); float textX = getWidth() / 2 - mTextBound.width() / 2; float textY = (titleBottom - fontMetrics.bottom + fontMetrics.top) / 2 - fontMetrics.top; canvas.drawText(titleText, textX, textY, titlePaint); } 绘制x轴同样的，x轴部分的高度也为view的1/8，x轴第一个值与原点之间的距离我们设置为x轴坐标间距离的1/3，也就是xCoordinateSpacing / 3; 再根据我们之前的需求分析，该view是有点击效果的，那么我们声明一个boolean类型的变量来判断该点是否被选中 //绘制x轴 private void drawXCoordinate(Canvas canvas) { int xCoordinateHeight = height - (height / 8); bgColorPaint.setColor(xCoordinateBgColor); coordinateTextPaint.setTextSize(xCoordinateTextSize); //先绘制背景颜色 canvas.drawRect(0, xCoordinateHeight, getWidth(), height, bgColorPaint); for (int i = 0; i &lt; xCoordinateData.size(); i++) { float textX = (xCoordinateSpacing / 3) + xCoordinateSpacing * i; float textY = (height - (height / 8)) + ((height - xCoordinateHeight) / 2); if (i == selectedIndex) { coordinateTextPaint.setColor(textSelectedColor); } else { coordinateTextPaint.setColor(textDefaultColor); } canvas.drawText(xCoordinateData.get(i), textX, textY, coordinateTextPaint); } } 绘制y轴y轴绘制步骤与x轴一致 //绘制y轴 private void drawYCoordinate(Canvas canvas) { coordinateTextPaint.setTextSize(yCoordinateTextSize); for (int i = 0; i &lt; yCoordinateData.size(); i++) { String text = yCoordinateData.get(i) + &quot;&quot;; float textX = (xCoordinateSpacing / 3) + xCoordinateSpacing * i; float textY = (height / 9) + (height / 8); if (i == selectedIndex) { coordinateTextPaint.setColor(textSelectedColor); } else { coordinateTextPaint.setColor(textDefaultColor); } canvas.drawText(text, textX, textY, coordinateTextPaint); } } 绘制图表//绘制图表 private void drawChart(Canvas canvas) { bgColorPaint.setColor(chartBgColor); int chartTop = height / 8; pointPaint.setColor(Color.BLUE); bgColorPaint.setColor(chartBgColor); //先绘制图表背景颜色 canvas.drawRect(0, chartTop, getWidth(), height - chartTop, bgColorPaint); bgColorPaint.setColor(lineColor); for (int i = 0; i &lt; yCoordinateData.size(); i++) { //绘制坐标线 float lineX = (xCoordinateSpacing / 3) + (xCoordinateSpacing * i); canvas.drawLine(lineX, height / 8, lineX, height - chartTop, bgColorPaint); } } 绘制数据点在绘制数据点前，我们要知道原点在哪儿，根据效果图，原点的x坐标在屏幕的最左侧，也就是0，y坐标在x坐标部分的顶部，也就是height - (height / 8);而数据点的x坐标，就是x轴的坐标加上x轴文字宽度的一半 private void drawPoint(Canvas canvas) { yOri = height - (height / 8); for(int i = 0; i &lt; yCoordinateData.size(); i++) { int x = (int) (this.x + this.xCoordinateSpacing * i + (getTextWidth(i) / 2)); int y = (int) (yOri - (((yOri * (1 - 0.5f)) * yCoordinateData.get(i)) / Collections.max(yCoordinateData))); canvas.drawCircle(x, y, 25, pointPaint); } } 绘制曲线前面提到，我们用贝塞尔曲线来完成曲线图中曲线的绘制，那么，我们先计算贝塞尔曲线中的控制点 先根据相邻点（P1，P2, P3）计算出相邻点的中点(P4， P5)，然后再计算相邻中点的中点(P6)。然后将（P4，P6, P5）组成的线段平移到经过P2的直线（P8，P2，P7）上。接着根据（P4，P6，P5，P2）的坐标计算出(P7，P8)的坐标。最后根据P7，P8等控制点画出三阶贝塞尔曲线。 private void initPoints() { yOri = height - (height / 8); mPoints = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; yCoordinateData.size(); i++) { int x = (int) (this.x + this.xCoordinateSpacing * i + (getTextWidth(i) / 2)); int y = (int) (yOri - (((yOri * (1 - 0.5f)) * yCoordinateData.get(i)) / Collections.max(yCoordinateData))); mPoints.add(new Point(x, y)); } //该点用于绘制从最后一个点到屏幕最右侧到二阶贝塞尔曲线 mPoints.add(new Point(getWidth(), (int) (height - (height / 2.5)))); } private void initMidPoints() { mMidPoints = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; mPoints.size(); i++) { Point midPoint = null; if (i == mPoints.size() - 1) { return; } else { midPoint = new Point((mPoints.get(i).x + mPoints.get(i + 1).x) / 2, (mPoints.get(i).y + mPoints.get(i + 1).y) / 2); } mMidPoints.add(midPoint); } } private void initMidMidPoints() { mMidMidPoints = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; mMidPoints.size(); i++) { Point midMidPoint = null; if (i == mMidPoints.size() - 1) { return; } else { midMidPoint = new Point((mMidPoints.get(i).x + mMidPoints.get(i + 1).x) / 2, (mMidPoints.get(i).y + mMidPoints.get(i + 1).y) / 2); } mMidMidPoints.add(midMidPoint); } } private void initControlPoints() { mControlPoints = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; mPoints.size(); i++) { if (i == 0 || i == mPoints.size() - 1) { continue; } else { Point before = new Point(); Point after = new Point(); before.x = mPoints.get(i).x - mMidMidPoints.get(i - 1).x + mMidPoints.get(i - 1).x; before.y = mPoints.get(i).y - mMidMidPoints.get(i - 1).y + mMidPoints.get(i - 1).y; after.x = mPoints.get(i).x - mMidMidPoints.get(i - 1).x + mMidPoints.get(i).x; after.y = mPoints.get(i).y - mMidMidPoints.get(i - 1).y + mMidPoints.get(i).y; mControlPoints.add(before); mControlPoints.add(after); } } } 得出mControlPoints就是我们最终得出来的控制点，接下来的事情就很简单了，我们再观察观察效果图，从屏幕最左边到第一个数据点和最后一个数据点到屏幕最右边，都有一个曲线连接，那么就随便写两个控制点用于绘制这两根曲线 //绘制曲线 private void drawCurve(Canvas canvas) { // 重置路径 Path curvePath = new Path(); curvePath.reset(); Path gradientPath = new Path(); gradientPath.reset(); //从屏幕左边绘制到第一个点 curvePath.moveTo(0, (float) (height - (height / 2.5)));// 起点 curvePath.quadTo(0, (float) (height - (height / 2.5)),// 控制点 mPoints.get(0).x, mPoints.get(0).y); gradientPath.moveTo(0, height - (height / 8)); gradientPath.lineTo(0, (float) (height - (height / 2.5))); gradientPath.quadTo(0, (float) (height - (height / 2.5)),// 控制点 mPoints.get(0).x, mPoints.get(0).y); for (int i = 0; i &lt; mPoints.size(); i++) { if (i == 0) {// 第一条为二阶贝塞尔 curvePath.moveTo(mPoints.get(i).x, mPoints.get(i).y);// 起点 curvePath.quadTo(mControlPoints.get(i).x, mControlPoints.get(i).y,// 控制点 mPoints.get(i + 1).x, mPoints.get(i + 1).y); gradientPath.quadTo(mControlPoints.get(i).x, mControlPoints.get(i).y,// 控制点 mPoints.get(i + 1).x, mPoints.get(i + 1).y); } else if (i &lt; mPoints.size() - 1) {// 三阶贝塞尔 //二阶 curvePath.quadTo(mControlPoints.get(2 * i - 1).x, mControlPoints.get(2 * i - 1).y, mPoints.get(i + 1).x, mPoints.get(i + 1).y); gradientPath.quadTo(mControlPoints.get(2 * i - 1).x, mControlPoints.get(2 * i - 1).y, mPoints.get(i + 1).x, mPoints.get(i + 1).y); } else if (i == mPoints.size() - 2) {// 最后一条为二阶贝塞尔 curvePath.moveTo(mPoints.get(i).x, mPoints.get(i).y);// 起点 curvePath.quadTo(mControlPoints.get(mControlPoints.size() - 1).x, mControlPoints.get(mControlPoints.size() - 1).y, mPoints.get(i + 1).x, mPoints.get(i + 1).y);// 终点 gradientPath.quadTo(mControlPoints.get(mControlPoints.size() - 1).x, mControlPoints.get(mControlPoints.size() - 1).y, mPoints.get(i + 1).x, mPoints.get(i + 1).y);//终点 } } //绘制渐变色 gradientPath.lineTo(getWidth(), height - (height / 8)); gradientPath.lineTo(0, height - (height / 8)); float left = 0; float top = getPaddingTop(); float bottom = height - (height / 8); //渐变色中最深的颜色用绘制曲线的颜色 LinearGradient lg = new LinearGradient(left, top, left, bottom, curveColor, chartMinimumColor, Shader.TileMode.CLAMP);// CLAMP重复最后一个颜色至最后 gradientColorPaint.setShader(lg); gradientColorPaint.setXfermode(new PorterDuffXfermode( android.graphics.PorterDuff.Mode.SRC_ATOP)); canvas.drawPath(gradientPath, gradientColorPaint); canvas.drawPath(curvePath, curvePaint); } 绘制浮窗要绘制出效果图那样的阴影很有难度，我暂且没有百分百的还原。我利用BlurMaskFilter来实现了类似阴影的效果，只需要在初始化画笔的时候，设置一下即可，当然，需要关闭硬件加速： setLayerType(LAYER_TYPE_SOFTWARE, floatBoxPaint); floatBoxPaint.setMaskFilter(new BlurMaskFilter(30, BlurMaskFilter.Blur.SOLID)); 设置好画笔后，接下来就绘制浮窗： private void drawFloatBox(Canvas canvas) { RectF rectF = new RectF(); for (int i = 0; i &lt; xCoordinateData.size(); i++) { if (i == selectedIndex) { rectF.left = mPoints.get(i).x - dip2px(47); rectF.right = mPoints.get(i).x + dip2px(47); rectF.top = mPoints.get(i).y - dip2px(70); rectF.bottom = mPoints.get(i).y + dip2px(90); canvas.drawRoundRect(rectF, 5, 5, floatBoxPaint); coordinateTextPaint.setTextSize(60); coordinateTextPaint.setColor(textSelectedColor); canvas.drawText(yCoordinateData.get(i) + &quot;&quot;, this.x + xCoordinateSpacing * i, mPoints.get(i).y - dip2px(35), coordinateTextPaint); } } } onTouchEvent点击事件以及滑动事件，其实比较简单，先来看看滑动事件：在处理滑动事件前，我们要明确几个东西： 数据点的最小x坐标以及最大x坐标，用于记录滑动距离 滑动事件 case MotionEvent.ACTION_MOVE: //如果屏幕不足以展示所有数据时 if (xCoordinateSpacing * xCoordinateData.size() &gt; getWidth()) { float dis = event.getX() - startX; startX = event.getX(); if (x + dis &lt; minX) { x = minX; } else if (x + dis &gt; maxX) { x = maxX; } else { x = x + dis; } invalidate(); } break; 点击事件/** * 点击X轴坐标或者折线节点 * * @param event */ private void clickAction(MotionEvent event) { int dp10 = dip2px(10); float eventX = event.getX(); float eventY = event.getY(); for (int i = 0; i &lt; xCoordinateData.size(); i++) { //节点 float x = mPoints.get(i).x; float y = mPoints.get(i).y; if (eventX &gt;= x - dp10 &amp;&amp; eventX &lt;= x + dp10 &amp;&amp; eventY &gt;= y - dp10 &amp;&amp; eventY &lt;= y + dp10 &amp;&amp; selectedIndex != i) {//每个节点周围10dp都是可点击区域 selectedIndex = i; invalidate(); return; } //X轴刻度 x = mPoints.get(i).x; y = (height - (height / 8)) + ((height - (height - (height / 8))) / 2); if (eventX &gt;= x - getTextWidth(i) / 2 - dp10 &amp;&amp; eventX &lt;= x + getTextWidth(i) + dp10 / 2 &amp;&amp; eventY &gt;= y - dp10 &amp;&amp; eventY &lt;= y + dp10 &amp;&amp; selectedIndex != i) { selectedIndex = i; invalidate(); return; } } } 完整的onTouchEvent代码 @Override public boolean onTouchEvent(MotionEvent event) { this.getParent().requestDisallowInterceptTouchEvent(true); switch (event.getAction()) { case MotionEvent.ACTION_DOWN: startX = event.getX(); break; case MotionEvent.ACTION_MOVE: //如果屏幕不足以展示所有数据时 if (xCoordinateSpacing * xCoordinateData.size() &gt; getWidth()) { float dis = event.getX() - startX; startX = event.getX(); if (x + dis &lt; minX) { x = minX; } else if (x + dis &gt; maxX) { x = maxX; } else { x = x + dis; } invalidate(); } break; case MotionEvent.ACTION_UP: clickAction(event); this.getParent().requestDisallowInterceptTouchEvent(false); break; case MotionEvent.ACTION_CANCEL: this.getParent().requestDisallowInterceptTouchEvent(false); break; } return true; } 到这里，整个曲线图已经完成了，来看看最终效果 结语其实最终效果与效果图还有些差距，包括浮窗的效果也不完美，不过倒是有个思路，将点击事件暴露出来，提供x，y坐标，点击后，弹出pop，可以达到一样的效果，有兴趣的话，各位可以试试看。文章中若有错误，还希望各位提出来 源码]]></content>
      <categories>
        <category>自定义View</category>
      </categories>
      <tags>
        <tag>自定义view</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017年终总结以及新年计划]]></title>
    <url>%2F2017%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%E4%BB%A5%E5%8F%8A%E6%96%B0%E5%B9%B4%E8%AE%A1%E5%88%92.html</url>
    <content type="text"><![CDATA[年终总结一年又过去了，今年学到了不少东西，也结交到几个大佬，很开心，又是充实（荒废）的一年。 今年年初的时候，给自己定了一个小目标： GitHub达到200start 坚持学习 写至少10篇博客 照目前的形式来看，除了坚持学习以外，其他的是已经凉了。。。 不过年目标不就是为了拿来凉的吗哈哈哈哈哈哈 虽然年目标凉了，但是也收获到不少东西。 学习上今年也学到不少东西，Android上学习了RecyclerView、自定义view、kotlin、组件化、学习了oss开源项目，从中收获颇丰：编程思想、代码规范、RxJava、单元测试，希望自己能在新的一年也能写出像oss这样的代码 当然也学习了不少杂七杂八的东西，比如：利用GitPage搭建hexo博客、利用VPS自建梯子、Linux、简单的算法，从源码层面上，对HashMap的理解更深刻了。 在此感谢Rank和浮舟两位大佬，耐心的为我讲解我提出的各种奇葩的问题，两位大佬被我气得半死，但仍没有怼我，我真的十分感激，也希望自己在技术上能更上一层楼。虽然两位大佬都不知道我博客的地址，不过依旧不能阻止我这颗感恩的心，哈哈哈。 工作上在今年年中的时候，进入了目前这家公司，虽然技术氛围稍差了些，不过同事都非常友好，有问题都能互相帮助，总监和主管也没有架子，工作交流一点也不压抑。 进入公司到现在半年的时间里，参与了公司一个新项目的开发，两个核心项目的数次迭代（敏捷开发伤不起啊），在公司给同事们分享了kotlin，给Android小组分享了组件化的优势，在公司也学到不少东西，也提升了自己的表达能力，还是比较满足。 跟同事分享了kotlin之后，与一个后端同事达成共识，使用kotlin完成一个APP，不过刚开始写没多久，公司业务就开始忙起来了，到后面基本上闲置了。。只完成了两个页面。。。惭愧 年计划 家里还堆了八本书，今年必须要看完了 为了明年去深圳做准备，也得把剩下的几科专升本的考试考了，给自己增加部分竞争力吧 学习也是万万不可放下的 至少每月写一篇博客 每天都学习一点算法 研习oss，学习其中的思想，让自己也写出这样漂亮的代码 GitHub上有300star吧 学习Linux 学习kotlin 基本上就这些了，今年要做的事情很多，尤其是升本，时间紧任务重。 那么新的一年也请大家多多指教]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[序列化基础知识]]></title>
    <url>%2F%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html</url>
    <content type="text"><![CDATA[序列化（serialization）在计算机科学的资料处理中，是指将数据结构或物件状态转换成可取用格式（例如存成档案，存于缓冲，或经由网络中传送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始物件相同语义的副本。对于许多物件，像是使用大量参照的复杂物件，这种序列化重建的过程并不容易。面向对象中的物件序列化，并不概括之前原始物件所关联的函式。这种过程也称为物件编组（marshalling）。从一系列字节提取数据结构的反向操作，是反序列化（也称为解编组, deserialization, unmarshalling）。 序列化在计算机科学中通常有以下定义: 对同步控制而言，表示强制在同一时间内进行单一存取。 在数据储存与传送的部分是指将一个对象存储至一个储存媒介，例如档案或是记亿体缓冲等，或者透过网络传送资料时进行编码的过程，可以是字节或是XML等格式。而字节的或XML编码格式可以还原完全相等的对象。这程序被应用在不同应用程序之间传送对象，以及服务器将对象储存到档案或数据库。相反的过程又称为反序列化。 字节序在说序列化之前，先简单说说字节序。计算机硬件有两种储存数据的方式，大端字节序、小端字节序， 大端字节序：高位字节在前，低位字节在后小端字节序：低位字节在前，高位字节在后 那么，什么时候用大端字节序，什么时候用小端字节序呢？ 一般来说，在网络传输中，我们规定使用大端字节序，当然，如果客户端与服务端约定好，也可以用小端字节序 而在本机处理的时候，一般是使用小端字节序，同理，你用大端也不是不可以，只是一种规定而已 XML什么是XML XML指可扩展标记语言 XML是一种标记语言，类似HTML XML的设计宗旨是传输数据，而非显示数据 XML标签没有被预定义，只需要使用者自行定义标签 XML被设计为具有自我描述性 XML的优点 格式统一，结构清晰 数据传输方便 XML的缺点 XML文件庞大，文件格式复杂，传输占带宽 需要花费较多的资源和时间用来解析 JSON什么是JSONJSON是一种由道格拉斯·克罗克福特构想设计、轻量级的数据交互语言，以文字为基础，且易于让人阅读。 JSON数据格式与语言无关，脱胎于JavaScript，但目前很多编程语言都支持JSON格式数据的生成和解析。 JSON构建于两种结构： 对象（object）：一个对象包含一系列非排序的键值对，一个对象以{开始，并以}结束。每个键值对之间用,分隔 数组（array）：一个数组是一个值的集合，一个数组以{开始，并以}结束，值之间使用,分隔 JSON的优点 数据格式简单，易于读写和维护 易于解析 占用带宽小 轻量级的数据交换格式 XML与JSON相比 两者的可读性、扩展性都不错 两者都拥有丰富的解析手段 在解析上，XML要占用更多的资源及时间，而JSON的解析速度更快 在传输速度上，JSON速度远超于XML 在数据体积上，XML所占体积比JSON更大 JSON更加轻量级 Protocol Buffer什么是Protocol BufferProtocol Buffer是Google出品的一款结构化数据的数据存储格式 通过将结构化的数据序列化，从而实现数据存储、RPC数据交换的功能，适用于传输数据量大和网络环境不稳定的数据存储，RPC数据交换的场景 Protocol Buffer的优点 轻量级 速度快 易于维护 Protocol Buffer的缺点 不适用于基于文本的标记文档建模 自解释性差，以二进制数据流方式存储，需要通过.proto文件才能了解到数据结构 Protocol Buffer相比于XML、JSON 在传输速度、文件大小上，Protocol Buffers更加轻量级，速度更快 在可读性上，如果不使用.proto文件，Protocol Buffers不可读 在使用上，Protocol Buffers比起JSON、XML稍显麻烦，需要先用Protocol写好并编译后，放到项目目录中 以上三种序列化，都是可以用来做网络传输的，那么按照开头我们所说的字节序规定，可以得出，这三者都是使用的大端字节序 Serializable和Parcelable作为一名Android开发者，对于Serializable的了解确实不足，请允许我对照着Android提供的序列化接口Parcelable一起说。 Serializable作为Java默认的序列化接口，使用起来非常方便，只需要实现Serializable接口，并添加一个serialVersionUID即可实现默认的序列化过程 通过Serializable方式来实现对象的序列化也很简单，只需要使用ObjectOutputStrean和ObjectInputStream即可： //序列化过程 User user = new User ObjectOutputStream out = new ObjectOutpuStream) new FileOutputStream(&quot;cache.txt&quot;)); out.writeObject(user); out.close(); //反序列化过程 ObjectInputStream in = new ObjectInputStream( new FileInputStream(&quot;cache.txt&quot;)); User user = (User)in.readObject(); in.close(); 序列化更核心的内容在writeObject里，这里就不再展开说了。 Serializable序列化主要使用反射和ObjectOutputStream实现序列化，众所周知，反射是影响效率的 值得一提的是，在JVM中，规定字节序是用大端字节序，不出意外的话，Serializable也是使用的大端字节序 Parcelable相比于Serializable，Android提供了一个效率更高的序列化接口：Parcelable。为什么说Parcelable效率更高呢，因为Parcelable实现原理是将一个完整的对象进行分解，而分解后每一部分都是Intent所支持的数据类型。不过，Parcelable效率更高很大一部分原因是因为Serializable是通过反射实现，这里就不举例实现Parcelable序列化了。 参考文章： 维基百科 JSON与XML的区别 快来看看 Google 出品的 Protocol Buffer，别只会用 JSON 和 XML 了 Protocol Buffer官网 序列化Serializable和Parcelable的理解和区别 Java的序列化实现解析 数据传输时的字节序]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecyclerView的基本使用与进阶（三）]]></title>
    <url>%2FRecyclerView%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E4%B8%8E%E8%BF%9B%E9%98%B6%EF%BC%88%E4%B8%89%EF%BC%89md.html</url>
    <content type="text"><![CDATA[回头看看自己的博客发现RecyclerVer系列还没写完。。完全忘记了。。。来补上，本篇分为两个部分： 第一部分： DefaultItemAnimator源码解析，即Google官方提供的item动画源码 第二部分： 如何写一个自己的item动画本篇就不贴效果图了，想看效果不妨自己去试试，我一直认为要学会怎么熟练的使用一个东西，就得了解这个东西是怎么运作的，不多说废话，正式开始： 第一部分打开源码可以看到该类继承自SimpleItemAnimator，再点开这个类看看，发现继承自RecyclerView.ItemAnimator，看来是SimpleItemAnimator对rv的动画进行了进一步的封装，最后DefaultItemAnimator再来具体实现想要的动画，这里不详谈SimpleItemAnimator，只看Google是怎么实现rv的item动画的，说一下涉及到的几个方法的作用： 方法解读 animateAdd(final RecyclerView.ViewHolder holder)：添加item时调用的动画，用adapter.notifyItemInster()时会调用该方法，若需要定制自己的动画，需要将返回值更改为true animateRemove(final RecyclerView.ViewHolder holder)：删除item时调用的动画，用adapter.notifyItemRemove()时会调用该方法，若需要定制自己的动画，需要将返回值更改为true animateMove(final RecyclerView.ViewHolder holder, int fromX, int fromY, int toX, int toY)：item移动时调用的动画，再说明白点就是添加、删除item时调用的方法，参数看名字就知道啥意思，不多做解释，若需要定制自己的动画，需要将该返回值更改为true animateChange(RecyclerView.ViewHolder oldHolder, RecyclerView.ViewHolder newHolder, int fromX, int fromY, int toX, int toY)：item接收到notifyItemChanged()或者notifyItemRangeChanged()调用的方法，同样，若需要定制自己的动画，需要将该返回值更改为true endAnimation(RecyclerView.ViewHolder item)：动画结束时调用的方法 canReuseUpdatedViewHolder(RecyclerView.ViewHolder viewHolder, List payloads):当item改变时调用该方法itemAnimator可以决定是否要重复使用相同的ViewHolder进行动画。 isRunning()：判断是否有动画正在执行 runPendingAnimations()：当有等待动画时调用 变量解读 private ArrayList&lt;RecyclerView.ViewHolder&gt; mPendingRemovals = new ArrayList&lt;&gt;(); private ArrayList&lt;RecyclerView.ViewHolder&gt; mPendingAdditions = new ArrayList&lt;&gt;(); private ArrayList mPendingMoves = new ArrayList&lt;&gt;(); private ArrayList mPendingChanges = new ArrayList&lt;&gt;(); ArrayList&lt;RecyclerView.ViewHolder&gt; mAddAnimations = new ArrayList&lt;&gt;(); ArrayList&lt;RecyclerView.ViewHolder&gt; mMoveAnimations = new ArrayList&lt;&gt;(); ArrayList&lt;RecyclerView.ViewHolder&gt; mRemoveAnimations = new ArrayList&lt;&gt;(); ArrayList&lt;RecyclerView.ViewHolder&gt; mChangeAnimations = new ArrayList&lt;&gt;(); ArrayList&lt;ArrayList&lt;RecyclerView.ViewHolder&gt;&gt; mAdditionsList = new ArrayList&lt;&gt;(); ArrayList&lt;ArrayList&gt; mMovesList = new ArrayList&lt;&gt;(); ArrayList&lt;ArrayList&gt; mChangesList = new ArrayList&lt;&gt;();能看到Google用了这么多的集合，具体作用是什么？很简单，看看runPendingAnimations()方法，我们可以得出一个结论：动画时有可能存在等待情况的！也就是说，当上一个动画还未执行完成的时候，下一个动画需要等待上一个动画执行完成后才可以执行，那万一等待了多个动画咋整，用集合保存起来呀，可是增加、删除、移动、刷新就四个动画，为啥有这么多集合，仔细看看前8个，是不是两两一组的，作用是什么呢？拿Add这组解释一下：可以看到Add这组有两个集合，mPendingAdditions和mAddAnimations，前者是等待处理的动画集合，后者就是处理中的动画集合，其他几个一样。那剩下三个是干嘛的？后面用到的时候再解释 isRunning()@Override public boolean isRunning() { return (!mPendingAdditions.isEmpty() || !mPendingChanges.isEmpty() || !mPendingMoves.isEmpty() || !mPendingRemovals.isEmpty() || !mMoveAnimations.isEmpty() || !mRemoveAnimations.isEmpty() || !mAddAnimations.isEmpty() || !mChangeAnimations.isEmpty() || !mMovesList.isEmpty() || !mAdditionsList.isEmpty() || !mChangesList.isEmpty()); } 这个似乎没啥好解释的。。只要其中一个动画集合不为空，则返回true，即：还有动画正在执行或需要执行 animateAdd()@Override public boolean animateAdd(final RecyclerView.ViewHolder holder) { resetAnimation(holder); ViewCompat.setAlpha(holder.itemView, 0); mPendingAdditions.add(holder); return true; } 一行一行的来解读，首先是resetAnimation(holder)，这个方法是用来干嘛的，点进去看看： private void resetAnimation(RecyclerView.ViewHolder holder) { AnimatorCompatHelper.clearInterpolator(holder.itemView); endAnimation(holder); } 第一个方法是用来干嘛的？层层抽丝剥茧，终于找到这样一段： @Override public void clearInterpolator(View view) { if (mDefaultInterpolator == null) { mDefaultInterpolator = new ValueAnimator().getInterpolator(); } view.animate().setInterpolator(mDefaultInterpolator); } } 看到了吗！view.animate().setInterpolator()，这是拿来干嘛的？ 官方解释： Sets the interpolator for the underlying animator that animates the requested properties. 翻译一下：为底层动画设置内插器，使动态化请求的属性。 具体作用是啥？就是用来修饰动画效果的，点到即止，不多做展开，来看看下一句 endAnimation()，调用结束动画 @Override public void endAnimation(RecyclerView.ViewHolder item) { final View view = item.itemView; ViewCompat.animate(view).cancel(); ... for (int i = mAdditionsList.size() - 1; i &gt;= 0; i--) { ArrayList&lt;RecyclerView.ViewHolder&gt; additions = mAdditionsList.get(i); if (additions.remove(item)) { ViewCompat.setAlpha(view, 1); dispatchAddFinished(item); if (additions.isEmpty()) { mAdditionsList.remove(i); } } } ... } 这一段就是将动画停止掉，将整个animateAdd方法连起来看看： 开始执行添加动画时，重置添加相关的动画 将需要执行添加动画的itemView的alpha值设置为0，即设置为不可见 将需要执行添加动画的itemView添加进等待处理添加动画的集合中这时候就会执行runPendingAnimations()方法： runPendingAnimations() public void runPendingAnimations() { boolean removalsPending = !mPendingRemovals.isEmpty();//如果待执行的删除动画为空时 boolean movesPending = !mPendingMoves.isEmpty();//如果待执行的移动动画为空时 boolean changesPending = !mPendingChanges.isEmpty();//如果待执行的刷新动画为空时 boolean additionsPending = !mPendingAdditions.isEmpty();//如果待执行的添加动画为空时 if (!removalsPending &amp;&amp; !movesPending &amp;&amp; !additionsPending &amp;&amp; !changesPending) { // 没有动画需要执行时 return; } // 首先，执行删除动画 for (RecyclerView.ViewHolder holder : mPendingRemovals) { animateRemoveImpl(holder); } mPendingRemovals.clear(); // 然后执行移动动画 if (movesPending) { final ArrayList&lt;MoveInfo&gt; moves = new ArrayList&lt;&gt;(); moves.addAll(mPendingMoves); mMovesList.add(moves); mPendingMoves.clear(); Runnable mover = new Runnable() { @Override public void run() { //将所有的删除动画放在一块一起执行 for (MoveInfo moveInfo : moves) { animateMoveImpl(moveInfo.holder, moveInfo.fromX, moveInfo.fromY, moveInfo.toX, moveInfo.toY); } //执行完成后清空 moves.clear(); mMovesList.remove(moves); } }; //如果有待执行的删除动画 if (removalsPending) { View view = moves.get(0).holder.itemView; ViewCompat.postOnAnimationDelayed(view, mover, getRemoveDuration()); } else { mover.run(); } } // 执行更新动画，与移动动画并行执行 if (changesPending) { final ArrayList&lt;ChangeInfo&gt; changes = new ArrayList&lt;&gt;(); changes.addAll(mPendingChanges); mChangesList.add(changes); mPendingChanges.clear(); Runnable changer = new Runnable() { @Override public void run() { //将所有待执行的更新动画一块执行 for (ChangeInfo change : changes) { animateChangeImpl(change); } //执行完成后清空 changes.clear(); mChangesList.remove(changes); } }; //如果有待执行的删除动画 if (removalsPending) { RecyclerView.ViewHolder holder = changes.get(0).oldHolder; ViewCompat.postOnAnimationDelayed(holder.itemView, changer, getRemoveDuration()); } else { changer.run(); } } // 执行添加动画 if (additionsPending) { final ArrayList&lt;RecyclerView.ViewHolder&gt; additions = new ArrayList&lt;&gt;(); additions.addAll(mPendingAdditions); mAdditionsList.add(additions); mPendingAdditions.clear(); Runnable adder = new Runnable() { @Override public void run() { //将所有添加动画放在一块执行 for (RecyclerView.ViewHolder holder : additions) { animateAddImpl(holder); } //动画执行完成后清空 additions.clear(); mAdditionsList.remove(additions); } }; //如果删除、移动、更新动画某一个为空时，获取每一个动画的持续时间 if (removalsPending || movesPending || changesPending) { long removeDuration = removalsPending ? getRemoveDuration() : 0; long moveDuration = movesPending ? getMoveDuration() : 0; long changeDuration = changesPending ? getChangeDuration() : 0; //添加动画的持续时间 = =删除动画持续时间+(移动动画或更新动画持续时间最长的一个) long totalDelay = removeDuration + Math.max(moveDuration, changeDuration); View view = additions.get(0).itemView; ViewCompat.postOnAnimationDelayed(view, adder, totalDelay); } else { adder.run(); } } } 以上就是处理待执行动画的所有步骤，有详细注释就不做解释了，细心的同学可能有注意到，添加、删除、移动、更新动画都有一个impl方法，这个方法里就是具体的动画！先来看看添加动画： animateAddImplvoid animateAddImpl(final RecyclerView.ViewHolder holder) { final View view = holder.itemView; final ViewPropertyAnimatorCompat animation = ViewCompat.animate(view); mAddAnimations.add(holder); animation.alpha(1).setDuration(getAddDuration()). setListener(new VpaListenerAdapter() { //动画开始时，调用dispatchAddStarting，即通知可以开始动画了！ @Override public void onAnimationStart(View view) { dispatchAddStarting(holder); } @Override public void onAnimationCancel(View view) { ViewCompat.setAlpha(view, 1); } //动画结束时，清空动画的监听，通知动画已结束，将处理中的动画集合移除当前这一个，如果当前已经没有动画在执行了，结束所有动画 @Override public void onAnimationEnd(View view) { animation.setListener(null); dispatchAddFinished(holder); mAddAnimations.remove(holder); dispatchFinishedWhenDone(); } }).start(); } 简单讲讲animateMove： animateMove()@Override public boolean animateMove(final RecyclerView.ViewHolder holder, int fromX, int fromY, int toX, int toY) { final View view = holder.itemView; fromX += ViewCompat.getTranslationX(holder.itemView); fromY += ViewCompat.getTranslationY(holder.itemView); resetAnimation(holder); int deltaX = toX - fromX; int deltaY = toY - fromY; if (deltaX == 0 &amp;&amp; deltaY == 0) { dispatchMoveFinished(holder); return false; } if (deltaX != 0) { ViewCompat.setTranslationX(view, -deltaX); } if (deltaY != 0) { ViewCompat.setTranslationY(view, -deltaY); } mPendingMoves.add(new MoveInfo(holder, fromX, fromY, toX, toY)); return true; } 其实很好理解，就说一下deltaX和deltaY，Google这样计算的目的就是为了在上一个item在移出的时候，当前这个item不会立即移动到当前上一个item的位置。 其他几个动画类似，就不做解释了，在这里也可以看出，具体是用的什么动画，动画时什么效果，都是在animatexxximpl中执行的，如果想要定制自己的动画，直接改这几个方法就可以了 接下来讲讲如何定制属于自己的item动画 第二部分前面说了，动画的具体实现都是在各个animateXXXImpl()中，那么要定制属于我们自己item动画，只需要更改animateXXXImpl()方法就可以了，那么我们先来做一个自己的添加动画 animateRemoveImpl()期望效果：这个item删除时，逐渐透明且慢慢缩小很简单的效果，我们只需要设置alpha，scaleX和scaleY就可以了： private void animateRemoveImpl(final RecyclerView.ViewHolder holder) { final View view = holder.itemView; final ViewPropertyAnimatorCompat animation = ViewCompat.animate(view); mRemoveAnimations.add(holder); animation.setDuration(getRemoveDuration()) .alpha(0).scaleY(0).scaleX(0).setListener(new VpaListenerAdapter() { @Override public void onAnimationStart(View view) { dispatchRemoveStarting(holder); } @Override public void onAnimationEnd(View view) { animation.setListener(null); ViewCompat.setAlpha(view, 1); ViewCompat.setScaleY(view, 1); ViewCompat.setScaleX(view, 1); dispatchRemoveFinished(holder); mRemoveAnimations.remove(holder); dispatchFinishedWhenDone(); } }).start(); } animateAddImpl()期望效果：从透明变为可见，并从小拉伸到正常大小其实就是跟remove反过来了而已，来看看代码： void animateAddImpl(final RecyclerView.ViewHolder holder) { final View view = holder.itemView; final ViewPropertyAnimatorCompat animation = ViewCompat.animate(view); mAddAnimations.add(holder); animation.alpha(1).scaleX(1).scaleY(1).setDuration(getAddDuration()). setListener(new VpaListenerAdapter() { @Override public void onAnimationStart(View view) { dispatchAddStarting(holder); } @Override public void onAnimationCancel(View view) { ViewCompat.setScaleX(view, 1); ViewCompat.setScaleY(view, 1); ViewCompat.setAlpha(view, 1); } @Override public void onAnimationEnd(View view) { animation.setListener(null); dispatchAddFinished(holder); mAddAnimations.remove(holder); dispatchFinishedWhenDone(); } }).start(); } 来看看效果： 添加Item的动画跟想象的不一样啊！回头看看animateAdd()： @Override public boolean animateAdd(final RecyclerView.ViewHolder holder) { resetAnimation(holder); ViewCompat.setAlpha(holder.itemView, 0); mPendingAdditions.add(holder); return true; } 这里还开始动画时只设置了alpha为透明，并没有把item缩小，那么改一下： @Override public boolean animateAdd(final RecyclerView.ViewHolder holder) { resetAnimation(holder); ViewCompat.setAlpha(holder.itemView, 0); ViewCompat.setScaleX(holder.itemView, 0); ViewCompat.setScaleY(holder.itemView, 0); mPendingAdditions.add(holder); return true; } 再来看看效果： 这下对了，快速连续点几下试试看呢：为啥前几个item都是透明的啊！刷新看看，又正常显示了！咋回事，想想最开始说的animateAdd()，我们在添加动画之前，先重置了动画，也就是resetAnimation()，点进去找到endAnimation()，看看添加相关的代码块： for (int i = mAdditionsList.size() - 1; i &gt;= 0; i--) { ArrayList&lt;RecyclerView.ViewHolder&gt; additions = mAdditionsList.get(i); if (additions.remove(item)) { ViewCompat.setAlpha(view, 1); dispatchAddFinished(item); if (additions.isEmpty()) { mAdditionsList.remove(i); } } 这下原因明了了，在我们快速点击添加时，会先执行这里面的代码，而这里只设置了alpha值，修改一下： for (int i = mAdditionsList.size() - 1; i &gt;= 0; i--) { ArrayList&lt;RecyclerView.ViewHolder&gt; additions = mAdditionsList.get(i); if (additions.remove(item)) { ViewCompat.setAlpha(view, 1); ViewCompat.setScaleY(view,1); ViewCompat.setScaleX(view,1); dispatchAddFinished(item); if (additions.isEmpty()) { mAdditionsList.remove(i); } } 再来看看效果： 完美 结语只讲了添加删除的动画，move和change都没有改动，篇幅太长就不做演示了，有兴趣可以自己尝试一下，不过难度最大的还是move，change的动画，毕竟要计算坐标，相对添加删除来说要难一点点，虽然也差不了多少，本篇到此结束，文中如有错误的地方，还请指出，谢谢！]]></content>
      <categories>
        <category>RecyclerView</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义view---强大的密码输入框]]></title>
    <url>%2F%E8%87%AA%E5%AE%9A%E4%B9%89view---%E5%BC%BA%E5%A4%A7%E7%9A%84%E5%AF%86%E7%A0%81%E8%BE%93%E5%85%A5%E6%A1%86.html</url>
    <content type="text"><![CDATA[我司之前有个需求，要求类似支付宝那样的密码支付，产品要求输入的当前字符需要是明文密码，1s后转换为圆点，原本想网上那么多密码输入框，肯定没问题，结果UI一出图就懵逼了，翻遍了各个角落，都找不到类似的密码输入框，没办法，自己写吧。使用方法，在gradle中添加：compile ‘com.rokudoll:PswText:1.0.0’即可使用当然绘制思路参照了其他大佬的思路，言归正传，先来看看效果图： 需求分析拿到效果图，再结合产品的要求，整理出以下要求：1、类似EditText的password模式，输入密码时，输入的当前密码为明文，而之前的密码变为圆点，1s后当前密码也变为圆点2、整体密码框为一个颜色，而已输入或当前输入密码位置的密码框为另一个颜色3、有阴影 代码实现自定义view的流程就不再赘述了，不太清楚的可以去看看鸿洋和郭林的教程，先写好自定义属性，按照之前分析的结果以及自己的一点想法，为了更方便的使用，就有了以下的自定义属性，目前没有使用枚举，全部都是以boolean值来规定使用哪种模式，不过之后会换成枚举，那么先来看看有哪些自定义属性： attrs 属性名 值 作用 pswLength integer 规定密码长度，默认为6 delayTime integer 延迟绘制密码圆点的时间 默认1000,1000=1s borderColor color 初始化密码框颜色 pswColor color 密码颜色 inputBorder_color color 输入时密码框颜色 borderShadow_color color 输入时密码框阴影颜色 psw_textSize sp 明文密码大小 borderRadius dp 不使用图片时，密码框圆角大小 borderImg drawable 密码框图片 inputBorderImg drawable 输入时变化的密码框图片 isDrawBorderImg boolean 是否使用图片绘制密码框，为true时设置borderImg、inputBorderImg才有效，默认为false isShowTextPsw boolean 按下back键时是否需要绘制当前位置的明文密码，默认为false isShowBorderShadow boolean 输入密码时是否需要绘制阴影,为true时设置borderShadow_color才有效，默认为false clearTextPsw boolean 是否只绘制明文密码，默认为false darkPsw boolean 是否只绘制圆点，默认为false isChangeBorder boolean 是否在输入密码时不更改密码框颜色，默认为false 设置好自定义属性后，就开始实现这个自定义控件了！首先肯定是计算宽高 onMeasure作为一个数学很差的人，计算这个的过程确实是比较糟心的。。直接看图吧图中说明两处：1、spacingWidth：为什么在宽度已知的情况下，spacingWidth = borderWidth / 4： 很简单，因为用边框的宽度除以4得到的大小刚好是能让我接受的大小，且在pswLength = 7、8、9、10的时候，宽度也比较合适，说白了就是一点点凑出来的2、borderWidth：为什么在宽度已知的情况下，borderWidth = (width 4) / ((5 pswLength) - 1)，这个其实很好理解，当宽度已知的时候，borderWidth = width / 6 - spacingWidth，即宽度除以6减去一个间隙的宽度就等于一个边框的宽度，而间隙的宽度 = borderWidth /4，那么我们换算成一个方程式来看看，就一目了然了,如果这个方程式还看不懂，那就去请教一下初中数学老师吧。。 来看看完整代码： @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { int widthSpec = MeasureSpec.getMode(widthMeasureSpec); int widthSize = MeasureSpec.getSize(widthMeasureSpec); int heightSpec = MeasureSpec.getMode(heightMeasureSpec); int heightSize = MeasureSpec.getSize(heightMeasureSpec); if (widthSpec == MeasureSpec.AT_MOST) { if (heightSpec != MeasureSpec.AT_MOST) {//高度已知但宽度未知时 spacingWidth = heightSize / 4; widthSize = (heightSize * pswLength) + (spacingWidth * (pswLength - 1)); borderWidth = heightSize; } else {//宽度，高度都未知时 widthSize = (borderWidth * pswLength) + (spacingWidth * (pswLength - 1)); heightSize = (int) (borderWidth + ((borderPaint.getStrokeWidth()) * 2)); } } else { //宽度已知但高度未知 if (heightSpec == MeasureSpec.AT_MOST) { borderWidth = (widthSize * 4) / (5 * pswLength); spacingWidth = borderWidth / 4; heightSize = (int) (borderWidth + ((borderPaint.getStrokeWidth()) * 2)); } } setMeasuredDimension(widthSize, heightSize); } 解释一下为什么高度要加上borderPaint.getStrokeWidth()2，很简单，如果直接取每个密码框的宽度作为高度的话，会出现密码框上下两根线绘制不完全的问题，因为画笔的宽度也是占了一定的大小的，所以我们在绘制高度时要留足够的高度来绘制整个view，为什么是2呢？因为上下两根线。。当然要加两次，所以是乘以2 按这种算法绘制出的view，其实右边还多了一个spacingWidth的宽度，因为我们给每一个边框都减去了一个spacingWidth的宽度，所以会多出一个spacingWidth的宽度，不过并不影响，我们可以在onDraw里把每一个密码框往右移0.5个spacingWidth的宽度，这样左右都空出了一小段空隙，视觉效果上也好看一点，直接来看看onDraw onDraw绘制pswLength数量个密码框先说说思路，我们用for循环的方式，循环绘制出pswLength个密码框，用canvas.drawRoundRect绘制密码框，如果使用图片的话，就绘制图片，那么来看看canvas.drawRoundRect需要传递的参数: drawRoundRect(RectF rect, float rx, float ry, Paint paint) rect：RectF对象，边框的具体坐标rx,ry：圆角x,y轴的半径paint：画笔那我们先来计算边框的具体坐标，来看看草稿：没错，这草稿就是这么low，数学差。。就是这么心酸，不过已经可以看出规律，前面说过，我们是用for循环的方式循环绘制出各个密码框，那么总结一下：top = 0 + (borderPaint.getStrokeWidth())bottom = height - (borderPaint.getStrokeWidth())left = i (borderWidth + spacingWidth)right = borderWidth + i (borderWidth + spacingWidth) = ((i + 1) borderWidth) + (i spacingWidth) 为什么top加上了borderPaint.getStrokeWidth()，而bottom又减去了borderPaint.getStrokeWidth()？ 还记得我们在onMeasure处计算高度时，增加了borderPaint.getStrokeWidth()*2吗，我们的密码框在绘制时，为了把整个view往下移一个画笔宽度的位置，就需要在top出加上一个画笔宽度的大小。而为什么bottom又要减去一个画笔宽度呢？仔细想想看，我们的bottom是用view的高度-一个画笔的宽度，而height是在边框的宽度基础上加上了两个画笔的宽度的，减去一个就正好是把整个view往下移了一个画笔的宽度 但是这样绘制出来的密码框，就像前面提过的，右边会多出一个spacingWidth，所以我们left和right的坐标需要再改进一下:int left = (int) ( (i (borderWidth + spacingWidth)) + (0.5 spacingWidth));int right = (int) (((i + 1) borderWidth) + (i spacingWidth) + (0.5 * spacingWidth));到这里并没有结束，为啥？因为说好的可以用图片来绘制边框，我们还没有实现这一步，不过也很简单，不需要重新计算坐标，直接贴该部分的完整代码： private void drawBorder(Canvas canvas, int height) { Bitmap bitmap = BitmapFactory.decodeResource(getResources(), borderImg); Rect src = new Rect(0, 0, bitmap.getWidth(), bitmap.getHeight()); for (int i = 0; i &lt; pswLength; i++) { int left = (int) ( (i * (borderWidth + spacingWidth)) + (0.5 * spacingWidth)); int right = (int) (((i + 1) * borderWidth) + (i * spacingWidth) + (0.5 * spacingWidth)); if (isBorderImg) { Rect dst = new Rect(left, 0, right, height); canvas.drawBitmap(bitmap, src, dst, borderPaint); } else { borderRectF.set(left, 0, right, height); canvas.drawRoundRect(borderRectF, borderRadius, borderRadius, borderPaint); } } bitmap.recycle(); } 只绘制明文密码模式这个很简单，就不多做解释了 private void drawText(Canvas canvas, String num, int i) { Rect mTextBound = new Rect(); pswTextPaint.getTextBounds(num, 0, num.length(), mTextBound); Paint.FontMetrics fontMetrics = pswTextPaint.getFontMetrics(); float textX = (float) ((i * (borderWidth + spacingWidth)) + (borderWidth / 2 - mTextBound.width() / 2) + (0.5 * spacingWidth)); float textY = (getMeasuredHeight() - fontMetrics.bottom + fontMetrics.top) / 2 - fontMetrics.top; if (saveResult != 0 || saveResult &lt; result.size()) { canvas.drawText(num, textX, textY, pswTextPaint); } } 说明一点，为什么在textX最后要加0.5*spacingWidth，因为我们绘制密码框的时候就多增加了这么多的宽度，所以绘制文字也要做同样的操作，同理，绘制圆点时也是一样，后面不多做赘述 只绘制圆点模式for (int i = 0; i &lt; result.size(); i++) { float circleX = (float) ((i * (borderWidth + spacingWidth)) + (borderWidth / 2) + (0.6 * spacingWidth)); float circleY = borderWidth / 2; int left = (int) (i * (borderWidth + spacingWidth) + (0.5 * spacingWidth)); int right = (int) (((i + 1) * borderWidth) + (i * spacingWidth) + (0.5 * spacingWidth)); drawBitmapOrBorder(canvas, left, right, height); canvas.drawCircle(circleX, circleY, dotRadius, pswDotPaint); } 绘制输入密码时密码框变换样式：private void drawBitmapOrBorder(Canvas canvas, int left, int right, int height) { if (isBorderImg) { Bitmap bitmap = BitmapFactory.decodeResource(getResources(), inputBorderImg); Rect src = new Rect(0, 0, bitmap.getWidth(), bitmap.getHeight()); Rect dst = new Rect(left, 0, right, height); canvas.drawBitmap(bitmap, src, dst, inputBorderPaint); bitmap.recycle(); } else { borderRectF.set(left, 0, right, height); canvas.drawRoundRect(borderRectF, borderRadius, borderRadius, inputBorderPaint); } } 输入密码时，输入的当前密码为明文，1s后变为圆点模式，即默认模式if (invalidated) { drawDelayCircle(canvas, height, dotRadius); return; } for (int i = 0; i &lt; result.size(); i++) { //密码明文 String num = result.get(i) + &quot;&quot;; //圆点坐标 float circleX = (float) (((i - 1) * (borderWidth + spacingWidth)) + (borderWidth / 2) + (0.6 * spacingWidth)); float circleY = borderWidth / 2; //密码框坐标 int left = (int) (i * (borderWidth + spacingWidth) + (0.5 * spacingWidth)); int right = (int) (((i + 1) * borderWidth) + (i * spacingWidth) + (0.5 * spacingWidth)); drawBitmapOrBorder(canvas, left, right, height); drawText(canvas, num, i); //当输入位置 = 输入的长度时，即判断当前绘制的位置是否为当前密码位置，若是则延迟1s后绘制圆点 if (i + 1 == result.size()) { handler.sendEmptyMessageDelayed(1, delayTime); } //若按下back键保存的密码 &gt; 输入的密码长度，则只绘制圆点 //即按下back键时，不绘制明文密码 if (!isShowTextPsw) { if (saveResult &gt; result.size()) { canvas.drawCircle((float) ((i * (borderWidth + spacingWidth)) + (borderWidth / 2 + (0.5 * spacingWidth))), circleY, dotRadius, pswDotPaint); } } //当输入第二个密码时，才开始绘制圆点 if (i &gt;= 1) { canvas.drawCircle(circleX, circleY, dotRadius, pswDotPaint); } } } 可能有同学注意到，这里我们计算的圆点坐标跟之前计算的不一样，为什么呢？因为在这里，我们计算的圆点坐标分为两种情况：1、输入密码时，已输入的密码变为圆点，那么我们的圆点坐标就应该是用(i - 1)的方式去计算，这样才能实现输入到第二个密码时，第一个密码变为圆点2、输入密码时，延迟1s后当前明文密码变为圆点，那么圆点坐标就应该是(i + 1)的方式计算 延迟绘制圆点private void drawDelayCircle(Canvas canvas, int height, int dotRadius) { invalidated = false; for (int i = 0; i &lt; result.size(); i++) { float circleX = (float) (((i - 1) * (borderWidth + spacingWidth)) + (borderWidth / 2) + (0.6 * spacingWidth)); float circleY = borderWidth / 2; int left = (int) (i * (borderWidth + spacingWidth) + (0.5 * spacingWidth)); int right = (int) (((i + 1) * borderWidth) + (i * spacingWidth) + (0.5 * spacingWidth)); canvas.drawCircle(circleX, circleY, dotRadius, pswDotPaint); drawBitmapOrBorder(canvas, left, right, height); } canvas.drawCircle((float) ((float) (((result.size() - 1) * (borderWidth + spacingWidth)) + (borderWidth / 2)) + (0.5 * spacingWidth)), borderWidth / 2, dotRadius, pswDotPaint); handler.removeMessages(1); } 以上就是全部的绘制逻辑，计算坐标这类似乎没什么好解释的，接下来就是自定义键盘，界面不需要我们自己再重新设计，用系统的就好，来看看代码 键盘class NumKeyListener implements OnKeyListener { @Override public boolean onKey(View v, int keyCode, KeyEvent event) { if (event.getAction() == KeyEvent.ACTION_DOWN) { if (event.isShiftPressed()) {//处理*#等键 return false; } if (keyCode &gt;= KeyEvent.KEYCODE_0 &amp;&amp; keyCode &lt;= KeyEvent.KEYCODE_9) {//只处理数字 if (result.size() &lt; pswLength) { result.add(keyCode - 7); invalidate(); ensureFinishInput(); } return true; } if (keyCode == KeyEvent.KEYCODE_DEL) { if (!result.isEmpty()) {//不为空，删除最后一个 saveResult = result.size(); result.remove(result.size() - 1); invalidate(); } return true; } if (keyCode == KeyEvent.KEYCODE_ENTER) { ensureFinishInput(); return true; } } return false; } 说明一下只处理数字那部分，为什么是keyCode - 7，我们点进源码看看可以看出，我们用keyCode - 7就刚好等于输入的数字最终效果： 结语以上就是该自定义view的全部说明，并未贴出全部的完整代码，如有需要可到GitHub查看完整源码，如果喜欢或觉得该控件对你有帮助还请点个star，文中如有错误还请指出，谢谢]]></content>
      <categories>
        <category>自定义View</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecyclerView的基本使用与进阶（二）]]></title>
    <url>%2FRecyclerView%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E4%B8%8E%E8%BF%9B%E9%98%B6%EF%BC%88%E4%BA%8C%EF%BC%89.html</url>
    <content type="text"><![CDATA[上一篇讲了RecyclerView最基本的使用，那点东西是不足以用到实际开发中的，一般在实际开发的时候，我们都会为每个item添加一条分割线，那么这篇文章就讲讲添加分割线的几种方式以及如何定制分割线，来画出酷炫的分割线 利用背景颜色来绘制简单分割线：比如我们将RecyclerView的背景颜色设置为黑色,然后在adapter中的onBindViewHodler给item设置margin就能达到分割线的效果： RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) holder.itemView.getLayoutParams(); params.topMargin = 2; holder.itemView.setLayoutParams(params); 或者利用ItemDicoration实现分割线，但其实也是利用背景颜色：新建类继承自ItemDicoration，覆写getItemOffsets() public class MyDividerItemDecoration extends RecyclerView.ItemDecoration { @Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) { super.getItemOffsets(outRect, view, parent, state); if (parent.getChildAdapterPosition(view) != 0) { outRect.top = 1; } } } 先判断是否是第一个item，如果是则不设置margin,然后我们在activity添加上 rv.addItemDecoration(new MyDividerItemDecoration()); 当然，还有一个更简单的方式，官方为我们提供了添加分割线的方法，只需要在activity中添加如下代码： rv.addItemDecoration(new DividerItemDecoration(this,DividerItemDecoration.VERTICAL)); 效果都是一样的，不过官方为我们提供的分割线可以更优雅的自定义分割线的样式在drawable中新建一个xml类型设置为shape: &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shape=&quot;rectangle&quot;&gt; &lt;gradient android:centerColor=&quot;@color/colorPrimary&quot; android:endColor=&quot;@color/colorPrimary&quot; android:startColor=&quot;@color/colorPrimary&quot; android:type=&quot;linear&quot;/&gt; &lt;size android:height=&quot;2dp&quot;/&gt; &lt;/shape&gt; 参数名称就不用解释了，看名字就知道啥意思，然后在当前APP引用的style中添加如下属性 &lt;item name=&quot;android:listDivider&quot;&gt;@drawable/divider&lt;/item&gt; 然后就大功告成了，效果图不贴了，有兴趣自己去试试吧既然已经引出了ItemDecoration，那么就要好好介绍一下该类官方的介绍是：An ItemDecoration allows the application to add a special drawing and layout offset to specific item views from the adapter’s data set. This can be useful for drawing dividers between items, highlights, visual grouping boundaries and more.简单翻译一下，允许adapter设置特定的视图或偏移量。就是说可以自定义偏移量甚至是视图那么我们来给每个item左边画个圆既然要在画布上画某个东西，那么就一定需要画笔 private Paint mPaint; 然后覆写onDraw方法,既然我们要给每一个item左边绘制一个圆，那么就要获取到每一个item @Override public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) { super.onDraw(c, parent, state); int childCount = parent.getChildCount(); for (int i = 0; i &lt;childCount; i++) { View view = parent.getChildAt(i); int index = parent.getChildAdapterPosition(view); } } 这样就获取到了每一个item，画圆就需要用canvas.drawCircle，其中有四个参数，分别是：float cx:圆心的x轴坐标float cy:圆心的y轴坐标float radius: 圆的半径Paint paint:这个就不解释了那么来看看圆心的x轴坐标怎么计算：首先，我们是将圆绘制在左边，那么我们就需要获取到左边的大小即：float left = view.getLeft()圆心的x轴左边就是 float cx = left / 2; 再来计算y轴坐标：y轴坐标计算相比之下就比较复杂一点，y轴圆心必定是在高的中间，所以我们需要获取到top和bottom float top = view.getTop(); float bottom = view.getBottom(); float cy = top + (bottom - top) / 2; 来看看效果附上完整代码: public class MyDividerItemDecoration extends RecyclerView.ItemDecoration { private Paint mPaint; private float mOffsetLeft;//距离左边的偏移量 private float mOffsetTop;//距离顶端的偏移量 private float radius;//圆的半径 public MyDividerItemDecoration(Context context) { mPaint = new Paint(); mPaint.setAntiAlias(true); mPaint.setColor(Color.BLACK); mOffsetLeft = context.getResources().getDimension(R.dimen.offSetLeft); radius = context.getResources().getDimension(R.dimen.radius); } @Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) { super.getItemOffsets(outRect, view, parent, state); if (parent.getChildAdapterPosition(view) != 0) { mOffsetTop = 1; outRect.top = 1; } outRect.left = (int) mOffsetLeft; } @Override public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) { super.onDraw(c, parent, state); int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) { View view = parent.getChildAt(i); int index = parent.getChildAdapterPosition(view); float left = view.getLeft(); float bottom = view.getBottom(); float top = view.getTop(); if (i == 0) { top = mOffsetTop; } float cx = left / 2; float cy = top + (bottom - top) / 2; c.drawCircle(cx,cy,radius,mPaint); } } 以上就是分割线的绘制及简单的itemDecoration的使用，如有错误，还请指出]]></content>
      <categories>
        <category>RecyclerView</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecyclewView的基本使用与进阶(一)]]></title>
    <url>%2FRecyclewView%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E4%B8%8E%E8%BF%9B%E9%98%B6%EF%BC%88%E4%B8%80%EF%BC%89%E4%B8%80.html</url>
    <content type="text"><![CDATA[最近打算把RecyclerView重新整理一下，从最基础的使用到各种定制化的进阶使用，开一个小系列，本系列不讲源码，只讲如何使用，如果有什么问题请指出本系列打算整理以下使用方法：1、RecyclerView的简单使用2、RecyclerView添加分割线，定制分割线3、RecyclerView添加item动画4、RecyclerView复杂布局5…(想到再加) RecyclerView的简单使用其实跟ListView使用步骤一样，只是有些细微的不同，先来张效果图那么接下来就开始本篇博客的正文，如何使用RecyclerView，步骤如下： 首先依赖RecyclerView在module的build.gradle中添加依赖： compile &apos;com.android.support:recyclerview-v7:25.3.1&apos; 使用RecyclerView完成依赖后，自然在是Activity的布局文件中使用RecyclerView： &lt;android.support.v7.widget.RecyclerView android:id=&quot;@+id/rv&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;/&gt; 再去Activity中绑定Id rv = (RecyclerView) findViewById(R.id.rv); 写Adapter接下来就是写Adapter了，与ListView不同的是，RecyclerView必须要写ViewHolder public class RvAdapter extends RecyclerView.Adapter&lt;RvAdapter.RvHolder&gt; { private List&lt;Integer&gt; list; public RvAdapter(List list) { this.list = list; } @Override public RvHolder onCreateViewHolder(ViewGroup parent, int viewType) { View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.rv_item, parent, false); return new RvHolder(view); } @Override public void onBindViewHolder(RvHolder holder, int position) { holder.img.setBackgroundResource(list.get(position)); } @Override public int getItemCount() { return list.size(); } class RvHolder extends RecyclerView.ViewHolder { ImageView img; public RvHolder(View itemView) { super(itemView); img = (ImageView) itemView.findViewById(R.id.img); } } } item的布局也很简单 &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot;&gt; &lt;ImageView android:id=&quot;@+id/img&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center&quot; android:layout_marginBottom=&quot;10dp&quot;/&gt; &lt;/LinearLayout&gt; 传递数据并设置RecyclerView的LayoutManager最后我们在Activity中将数据传到adapter中 public class MainActivity extends AppCompatActivity { private RecyclerView rv; private List&lt;Integer&gt; list; private RvAdapter adapter; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); rv = (RecyclerView) findViewById(R.id.rv); list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 3; i++) { list.add(R.mipmap.p1); list.add(R.mipmap.p2); list.add(R.mipmap.p3); list.add(R.mipmap.p4); list.add(R.mipmap.p5); list.add(R.mipmap.p6); } adapter = new RvAdapter(list); rv.setLayoutManager(new LinearLayoutManager(this)); rv.setAdapter(adapter); } } 这样就大功告成了，来看看效果: GridLayout接下来看看RecyclerView的强大之处，如果我们想要GridView的效果怎么办？重写？no no no no，只需要修改一句代码即可，就是我们的LayoutManager： rv.setLayoutManager(new GridLayoutManager(this,2)); 来看看效果： 瀑布流瀑布流实现也非常的简单,同样是更改LayoutManager： rv.setLayoutManager(new StaggeredGridLayoutManager(2,StaggeredGridLayoutManager.VERTICAL)); 先来看看效果：咋跟Grid一样的效果？？不急，先理清思路，实现瀑布流关键就在于那个不同的高度，既然这样，就直接给每个item设置不同的高度就行了，那么就去adapter中去设置随机高度： private void randomHeight(List&lt;Integer&gt; list){ heights = new ArrayList&lt;&gt;(); for (int i = 0; i &lt;list.size() ; i++) { heights.add((int) (300+Math.random()*300)); } } 然后在onBindViewHolder中给每个item设置随机高度： RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) holder.itemView.getLayoutParams(); params.height = heights.get(position); holder.itemView.setLayoutParams(params); 最后来看看效果： 虽然比较简陋，也算是一个简单的瀑布流，各位根据自己的需求更改吧，下一篇讲讲分割线的绘制]]></content>
      <categories>
        <category>RecyclerView</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DialogFragment与Fragment之间互相传值]]></title>
    <url>%2FDialogFragment%E4%B8%8EFragment%E4%B9%8B%E9%97%B4%E4%BA%92%E7%9B%B8%E4%BC%A0%E5%80%BC.html</url>
    <content type="text"><![CDATA[DialogFragment与Fragment互相传值有两种情况： 一、DialogFragment与Fragment在同一Activity在这种情况下，就利用onActivityResult来取值，与Activity获取另一个Activity的返回值一样，首先定义一个REQUEST的静态常量： public static final int REQUEST=1; 然后在需要取值的Fragemnt中，覆写onActivityResult： @Override public void onActivityResult(int requestCode,int resultCode,Intent data){ super.onActivityResult(requestCode,resultCode,data); if(requestCode == REQUEST){ //data.getStringExtra就获取到了DialogFragment所传递过来的值 String evaluate = data.getStringExtra(DialogFragment.RESPONSE}; } 接下来是DialogFragment：同样的，需要先定义一个RESPONSE; public static final String RESPONSE=&quot;response&quot;; 至于为什么是String而不是int，boolean类型的，只是因为，这个RESPONSE只是一个键名，就跟Intent的put，get方法一样，需要同一个键才能获取到相应的值，接下来就是写一个方法，用来传递给Fragment protected void setResult(){ //先判断是否有targetFragment if(getTargetFragment == null){ return; }else{ Intent intent = new Intent(); intent.putExtra(RESPONSE,&quot;需要传递的值&quot;); getTragetFragment.onActivityResult(Fragment.REQUEST,Acitivity.RESULT.OK,intent); } } 那么，在Fragment中显示DialogFragment之前，需要先添加targetFragment才行，否则在DialogFragment中无法找到targetFragment,就无法执行存值的逻辑 DialogFragment dialog = new DialogFragment(); dialog.setTragetFragment(Fragment.this,REQUEST); dialog.show(getFragmentManager,&quot;dialog&quot;); `这样，DialogFragment传值给Fragment就完成了，Fragment传值给DialogFragment也是同理 二、DialogFragment与Fragment不在同一Activity 与两个Activity之间传值一样，使用Intent传值，在AFrament中传值给BFragment： Intent intent = new Intent(getActivity,BFragment.class); intent.putExtra(BFragment.EXTRA_STRING,&quot;需要传递的值&quot;); startActivity(intent); 值已经传递给BFragment了，接下来是在BFragment中取值： String data = getActivity.getIntent().getString Extra(EXTRA_STRING); 以上就是DialogFragment与Fragment之间互相传值的方法，若文章中有什么差错还请各位指出，谢谢]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVP+Retrofit+RxJava+ButterKnife的简单使用]]></title>
    <url>%2FMVP%2BRetrofit%2BRxJava%2BButterKnife%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8.html</url>
    <content type="text"><![CDATA[最近学习了挺多东西，所以想写个demo把最近所学的全都用到，于是就有了这篇博客，这个demo实现的功能特别简单，就是一个查询天气，并且放到textview及recyclerview上显示出来，用的mvp设计框架，也是这两天才稍微看懂的东西，如果有错，还请各路大佬指出，那么废话不多说，先上效果图 确定功能或需求 从图中能看出有以下功能： 显示progress 隐藏progress 请求数据成功或失败弹出toast提示 将获取到的数据设置到TextView上 将获取到的数据设置到recyclerview上 如果查询出错清空所有的数据确定V层接口确定了功能那么就是如何实现了，根据mvp的思想，V层只负责初始化view，并将view层接收到的数据（即EditText等）传递到P层，P层再传递给M层，让M层操作数据，包括存储和耗时操作等，然后M层再将数据传回给P层，P层来更新UI，说得再明白点，mvp就是面向接口，那么m,v,p层的接口该怎么写呢？很简单，根据上面我们列出的功能来写相应的接口，直接来看代码： public interface IMainActivity { //显示progress void showProgress(); //隐藏progress void hideProgress(); /* * 设置文本 * @param temperaturestr:今日温度,@param coldstr:今日建议,@param citystr:城市 * @param yesterdayflstr：昨日风力,@param yesterdayfxstr：昨日风向,@param yesterdayhighstr：昨日最高温 * @param yesterdaylowstr：昨日最低温,@param yesterdaytypestr：昨日天气类型,@param yesterdaydatestr：昨日时间 * * */ void setText(String temperaturestr, String coldstr, String citystr, String yesterdayflstr, String yesterdayfxstr, String yesterdayhighstr, String yesterdaylowstr, String yesterdaytypestr, String yesterdaydatestr); //设置item void setItem(MyAdapter adapter); //Toast提示 void showMsg(String msg); //输入错误时清空textview,recyclerview的item void clearAll(); } V层代码具体实现那么现在V层，也就是Activity只需要实现这个接口即可，看代码： public class MainActivity extends Activity implements IMainActivity { @BindView(R.id.temperature) TextView temperature; @BindView(R.id.rv) RecyclerView rv; @BindView(R.id.citykey) EditText citykey; @BindView(R.id.query) Button query; @BindView(R.id.progress) ProgressBar progress; private WeatherPresenter weatherPresenter; //初始化控件，并new出P层实例 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ButterKnife.bind(this); weatherPresenter = new WeatherPresenter(this); } //点击监听，用P层实例去调用请求数据的接口 @OnClick(R.id.query) void query() { if (citykey.getText().toString().equals(&quot;&quot;)) { citykey.setError(&quot;不能为空&quot;); } weatherPresenter.validateCredentials(citykey.getText().toString()); } @Override public void showProgress() { progress.setVisibility(View.VISIBLE); } @Override public void hideProgress() { progress.setVisibility(View.GONE); } @Override public void setText(String temperaturestr, String coldstr, String citystr, String yesterdayflstr, String yesterdayfxstr, String yesterdayhighstr, String yesterdaylowstr, String yesterdaytypestr, String yesterdaydatestr) { temperature.setText(&quot;城市：&quot; + citystr + &quot;\n&quot; + &quot;今日温度：&quot; + temperaturestr + &quot;\n&quot; + &quot;今日建议：&quot; + coldstr + &quot;\n&quot; + &quot;昨日时间：&quot; + yesterdaydatestr + &quot;\n&quot; + &quot;昨日天气：&quot; + yesterdaytypestr + &quot;\n&quot; + &quot;昨日最&quot; + yesterdayhighstr + &quot;\n&quot; + &quot;昨日最&quot; + yesterdaylowstr + &quot;\n&quot; + &quot;昨日风力：&quot; + yesterdayflstr + &quot;\n&quot; + &quot;昨日风向：&quot; + yesterdayfxstr ); } //设置适配器，显示recyclerview，adapter由P层传回 @Override public void setItem(MyAdapter adapter) { rv.setLayoutManager(new LinearLayoutManager(this)); rv.setAdapter(adapter); } @Override public void showMsg(String msg) { Toast.makeText(this, msg, Toast.LENGTH_SHORT).show(); } @Override public void clearAll() { rv.setAdapter(null); temperature.setText(&quot;&quot;); } 确定P层接口和具体实现这里注意一下，我在onCreate方法中实例化了P层，原因就是要让P层拿到V层的实例，这样才能让P层去操作UI，那么P层需要做哪些操作呢，前面说了，M层去操作数据，P层操作UI，再看看我们的效果图，V层获取到了EditText输入的字符串，并且点击查询后获取到了相应的数据，现在要做的，就是把V层获取到的数据传递给M层，让M层去做耗时操作，但是MVP模式，V层是不能直接跟M层进行交互的，怎么办？很简单，我们还有P层没用到，P层的作用就是V层和M层的桥梁，让V层把数据通过P层传递给M层即可，具体怎么做？我们再来分析一下，V层需要传递数据给M层，那么P层就需要一个方法，来接收V层的数据，这个方法就是点击查询按钮后要执行的方法，那么P层现在要做的工作就很简单了let me show you code： public interface IWeatherPresenter { //请求数据 void validateCredentials(String citykey); } 接下来在定义一个类去实现该接口 //进行数据请求，请求时显示progress @Override public void validateCredentials(String citykey) { view.showProgress(); model.getWeather(citykey, this); } 确定M层接口及M层的具体实现有同学就要问了，model.getWeather又是从哪里来的方法，都是什么鬼，不要急，前面说了，P层需要一个方法来接收V层传递过来数据，然后才能让P层把数据传递给M层，那model.getWeather肯定就是M层的方法了，没错，M层需要做耗时操作，而具体要查询哪一个城市的天气数据，就是从V层传递过来的，逻辑是不是一下就通了，再来分析下M层，M层需要的就是耗时操作，那么耗时操作就有两种可能：1、请求成功2、请求失败所以我们M层的接口写成这样： public interface IWeatherModel { interface OnLinstener { //请求失败 void onFailed(); //请求成功 void onSuccess(); } //请求数据 void getWeather(String citykey, OnLinstener linstener); } 现在万事具备，就剩个M层的类来实现这个接口就行了，但是，先暂停一下，看看我们的标题，基于retrofit+rxjava，前面一直没用，当然就是在这个时候来用的，先给个完整的URL，现在来看看retrofit用来实现get请求的接口： public interface APIService { @GET(&quot;/weather_mini&quot;) Observable&lt;Bean&gt; getApi(@Query(&quot;citykey&quot;) String citykey); } RxJava的简单使用有同学要问，返回的Observable是个啥，这个是rxjava特有的，我能力不足，只限于能用的阶段。。还不能很好的解释其中的原理，有兴趣的可以去看看这位大佬rxjava的系列文章，接下来是用于解析json的bean类，太长就不放了。。有兴趣可以下载源码看看，现在，要开始写M层的逻辑了，M层就是用来操作数据的，说白了就是耗时操作，存储数据，看代码： public class WeatherModel implements IWeatherModel { private static final String TAG = &quot;WeatherModel&quot;; private Retrofit retrofit; private OkHttpClient client; private MyBean bean; //进行耗时操作，访问数据 @Override public void getWeather(String citykey, final OnLinstener linstener) { Interceptor interceptor = new Interceptor() { @Override public Response intercept(Chain chain) throws IOException { Request request = chain.request().newBuilder().build(); return chain.proceed(request); } }; client = new OkHttpClient.Builder().addInterceptor(interceptor).build(); retrofit = new Retrofit.Builder() .baseUrl(&quot;http://wthrcdn.etouch.cn&quot;) .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .addConverterFactory(GsonConverterFactory.create()) .client(client) .build(); APIService api = retrofit.create(APIService.class); api.getApi(citykey) .subscribeOn(Schedulers.io())//在io线程执行 .observeOn(AndroidSchedulers.mainThread())//执行完成后回调给UI线程 .subscribe(new Observer&lt;Bean&gt;() { @Override public void onSubscribe(Disposable d) { Log.i(TAG, &quot;onSubscribe: &quot;); } @Override public void onNext(Bean value) { if (value.getDesc().equals(&quot;OK&quot;)) { bean = new MyBean(); bean.setWendu(value.getData().getWendu()); bean.setGanmao(value.getData().getGanmao()); bean.setCity(value.getData().getCity()); bean.setYesterdayfl(value.getData().getYesterday().getFl()); bean.setYesterdayfx(value.getData().getYesterday().getFx()); bean.setYesterdayhigh(value.getData().getYesterday().getHigh()); bean.setYesterdaylow(value.getData().getYesterday().getLow()); bean.setYesterdaytype(value.getData().getYesterday().getType()); bean.setYesterdaydate(value.getData().getYesterday().getDate()); bean.setList(value.getData().getForecast()); bean.setMsg(&quot;请求数据正确，请稍后&quot;); linstener.onSuccess(); Log.i(TAG, &quot;onNext: &quot;); } else { bean = new MyBean(); bean.setMsg(&quot;请求数据错误，请重新输入&quot;); linstener.onFailed(); } } @Override public void onError(Throwable e) { linstener.onFailed(); Log.e(TAG, &quot;onError: &quot;); } @Override public void onComplete() { Log.i(TAG, &quot;onComplete: &quot;); } }); } 完整的M层代码我写了另一个bean类来存储所有数据，这样P层才能直接把数据拿来用，但是在M层存储好说，怎么在P层取出来呢，如果两个类持有的不是同一个对象，那P层肯定是取不出数据的，很简单，有什么需求就写什么接口，P层需要M层存储的bean类，那么我们在M层的接口再写个getBean的方法，然后让M层去实现不就行了，P层拿到M层的实例直接调用方法就可以拿到我们想要的bean类了，所以完整的M层接口代码： public interface IWeatherModel { interface OnLinstener { //请求失败 void onFailed(); //请求成功 void onSuccess(); } //请求数据 void getWeather(String citykey, OnLinstener linstener); //获取bean类 MyBean getBean(); } 完整的M层代码： public class WeatherModel implements IWeatherModel { private static final String TAG = &quot;WeatherModel&quot;; private Retrofit retrofit; private OkHttpClient client; private MyBean bean; //进行耗时操作，访问数据 @Override public void getWeather(String citykey, final OnLinstener linstener) { Interceptor interceptor = new Interceptor() { @Override public Response intercept(Chain chain) throws IOException { Request request = chain.request().newBuilder().build(); return chain.proceed(request); } }; client = new OkHttpClient.Builder().addInterceptor(interceptor).build(); retrofit = new Retrofit.Builder() .baseUrl(&quot;http://wthrcdn.etouch.cn&quot;) .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .addConverterFactory(GsonConverterFactory.create()) .client(client) .build(); APIService api = retrofit.create(APIService.class); api.getApi(citykey) .subscribeOn(Schedulers.io())//在io线程执行 .observeOn(AndroidSchedulers.mainThread())//执行完成后回调给UI线程 .subscribe(new Observer&lt;Bean&gt;() { @Override public void onSubscribe(Disposable d) { Log.i(TAG, &quot;onSubscribe: &quot;); } @Override public void onNext(Bean value) { if (value.getDesc().equals(&quot;OK&quot;)) { bean = new MyBean(); bean.setWendu(value.getData().getWendu()); bean.setGanmao(value.getData().getGanmao()); bean.setCity(value.getData().getCity()); bean.setYesterdayfl(value.getData().getYesterday().getFl()); bean.setYesterdayfx(value.getData().getYesterday().getFx()); bean.setYesterdayhigh(value.getData().getYesterday().getHigh()); bean.setYesterdaylow(value.getData().getYesterday().getLow()); bean.setYesterdaytype(value.getData().getYesterday().getType()); bean.setYesterdaydate(value.getData().getYesterday().getDate()); bean.setList(value.getData().getForecast()); bean.setMsg(&quot;请求数据正确，请稍后&quot;); linstener.onSuccess(); Log.i(TAG, &quot;onNext: &quot;); } else { bean = new MyBean(); bean.setMsg(&quot;请求数据错误，请重新输入&quot;); linstener.onFailed(); } } @Override public void onError(Throwable e) { linstener.onFailed(); Log.e(TAG, &quot;onError: &quot;); } @Override public void onComplete() { Log.i(TAG, &quot;onComplete: &quot;); } }); } //将保存的MyBean类返回给P层 @Override public MyBean getBean() { return this.bean; } } P层完整的代码 P层完整的代码： public class WeatherPresenter implements IWeatherPresenter, IWeatherModel.OnLinstener { private IMainActivity view; private IWeatherModel model; private List&lt;Bean.Data.forecast&gt; list; //构造器，需要传入v层实例，并new一个m层实例，以达到让P层实现桥梁的作用 public WeatherPresenter(IMainActivity view) { this.view = view; this.model = new WeatherModel(); } //进行数据请求，请求时显示progress @Override public void validateCredentials(String citykey) { view.showProgress(); model.getWeather(citykey, this); } //数据请求失败时隐藏progress @Override public void onFailed() { view.clearAll(); MyBean bean = model.getBean(); view.showMsg(bean.getMsg()); view.hideProgress(); } //数据请求成功后将数据显示在控件上,且在请求成功后隐藏progress @Override public void onSuccess() { MyBean bean = model.getBean(); if (bean.getMsg().equals(&quot;请求数据正确，请稍后&quot;)) { view.showMsg(bean.getMsg()); view.setText(bean.getWendu(), bean.getGanmao(), bean.getCity(), bean.getYesterdayfl(), bean.getYesterdayfx(), bean.getYesterdayhigh(), bean.getYesterdaylow(), bean.getYesterdaytype(), bean.getYesterdaydate()); list = bean.getList(); MyAdapter adapter = new MyAdapter((Context) view, list); view.setItem(adapter); view.hideProgress(); } } } recyclerview的adapter非常简单，就不贴出来了，有兴趣的话就下载源码自己看看吧，欢迎各位大佬提出建议 demoGitHub地址demo的下载地址]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
</search>
