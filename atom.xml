<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>rokudol的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.rokudol.cn/"/>
  <updated>2018-04-07T02:37:46.199Z</updated>
  <id>http://blog.rokudol.cn/</id>
  
  <author>
    <name>rokudol</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2017年终总结以及新年计划</title>
    <link href="http://blog.rokudol.cn/2017%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%E4%BB%A5%E5%8F%8A%E6%96%B0%E5%B9%B4%E8%AE%A1%E5%88%92.html"/>
    <id>http://blog.rokudol.cn/2017年终总结以及新年计划.html</id>
    <published>2017-12-31T12:12:42.000Z</published>
    <updated>2018-04-07T02:37:46.199Z</updated>
    
    <content type="html"><![CDATA[<h1 id="年终总结"><a href="#年终总结" class="headerlink" title="年终总结"></a>年终总结</h1><p>一年又过去了，今年学到了不少东西，也结交到几个大佬，很开心，又是充实（荒废）的一年。</p><p>今年年初的时候，给自己定了一个小目标：</p><ul><li>GitHub达到200start</li><li>坚持学习</li><li>写至少10篇博客</li></ul><p>照目前的形式来看，除了坚持学习以外，其他的是已经凉了。。。</p><p>不过年目标不就是为了拿来凉的吗哈哈哈哈哈哈</p><p>虽然年目标凉了，但是也收获到不少东西。</p><a id="more"></a><h2 id="学习上"><a href="#学习上" class="headerlink" title="学习上"></a>学习上</h2><p>今年也学到不少东西，Android上学习了RecyclerView、自定义view、kotlin、组件化、学习了oss开源项目，从中收获颇丰：编程思想、代码规范、RxJava、单元测试，希望自己能在新的一年也能写出像oss这样的代码</p><p>当然也学习了不少杂七杂八的东西，比如：利用GitPage搭建hexo博客、利用VPS自建梯子、Linux、简单的算法，从源码层面上，对HashMap的理解更深刻了。</p><p>在此感谢Rank和浮舟两位大佬，耐心的为我讲解我提出的各种奇葩的问题，两位大佬被我气得半死，但仍没有怼我，我真的十分感激，也希望自己在技术上能更上一层楼。虽然两位大佬都不知道我博客的地址，不过依旧不能阻止我这颗感恩的心，哈哈哈。</p><h2 id="工作上"><a href="#工作上" class="headerlink" title="工作上"></a>工作上</h2><p>在今年年中的时候，进入了目前这家公司，虽然技术氛围稍差了些，不过同事都非常友好，有问题都能互相帮助，总监和主管也没有架子，工作交流一点也不压抑。</p><p>进入公司到现在半年的时间里，参与了公司一个新项目的开发，两个核心项目的数次迭代（敏捷开发伤不起啊），在公司给同事们分享了kotlin，给Android小组分享了组件化的优势，在公司也学到不少东西，也提升了自己的表达能力，还是比较满足。</p><p>跟同事分享了kotlin之后，与一个后端同事达成共识，使用kotlin完成一个APP，不过刚开始写没多久，公司业务就开始忙起来了，到后面基本上闲置了。。只完成了两个页面。。。惭愧</p><h1 id="年计划"><a href="#年计划" class="headerlink" title="年计划"></a>年计划</h1><ul><li>家里还堆了八本书，今年必须要看完了</li><li>为了明年去深圳做准备，也得把剩下的几科专升本的考试考了，给自己增加部分竞争力吧</li><li>学习也是万万不可放下的</li><li>至少每月写一篇博客</li><li>每天都学习一点算法</li><li>研习oss，学习其中的思想，让自己也写出这样漂亮的代码</li><li>GitHub上有300star吧</li><li>学习Linux</li><li>学习kotlin</li></ul><p>基本上就这些了，今年要做的事情很多，尤其是升本，时间紧任务重。</p><p>那么新的一年也请大家多多指教</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;年终总结&quot;&gt;&lt;a href=&quot;#年终总结&quot; class=&quot;headerlink&quot; title=&quot;年终总结&quot;&gt;&lt;/a&gt;年终总结&lt;/h1&gt;&lt;p&gt;一年又过去了，今年学到了不少东西，也结交到几个大佬，很开心，又是充实（荒废）的一年。&lt;/p&gt;
&lt;p&gt;今年年初的时候，给自己定了一个小目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GitHub达到200start&lt;/li&gt;
&lt;li&gt;坚持学习&lt;/li&gt;
&lt;li&gt;写至少10篇博客&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;照目前的形式来看，除了坚持学习以外，其他的是已经凉了。。。&lt;/p&gt;
&lt;p&gt;不过年目标不就是为了拿来凉的吗哈哈哈哈哈哈&lt;/p&gt;
&lt;p&gt;虽然年目标凉了，但是也收获到不少东西。&lt;/p&gt;
    
    </summary>
    
      <category term="总结" scheme="http://blog.rokudol.cn/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="总结" scheme="http://blog.rokudol.cn/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>序列化基础知识</title>
    <link href="http://blog.rokudol.cn/%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html"/>
    <id>http://blog.rokudol.cn/序列化基础知识.html</id>
    <published>2017-12-27T03:16:01.000Z</published>
    <updated>2018-04-07T02:37:46.200Z</updated>
    
    <content type="html"><![CDATA[<p>序列化（serialization）在计算机科学的资料处理中，是指将数据结构或物件状态转换成可取用格式（例如存成档案，存于缓冲，或经由网络中传送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始物件相同语义的副本。对于许多物件，像是使用大量参照的复杂物件，这种序列化重建的过程并不容易。面向对象中的物件序列化，并不概括之前原始物件所关联的函式。这种过程也称为物件编组（marshalling）。从一系列字节提取数据结构的反向操作，是反序列化（也称为解编组, deserialization, unmarshalling）。 </p><p>序列化在计算机科学中通常有以下定义:</p><ul><li>对同步控制而言，表示强制在同一时间内进行单一存取。</li><li>在数据储存与传送的部分是指将一个对象存储至一个储存媒介，例如档案或是记亿体缓冲等，或者透过网络传送资料时进行编码的过程，可以是字节或是XML等格式。而字节的或XML编码格式可以还原完全相等的对象。这程序被应用在不同应用程序之间传送对象，以及服务器将对象储存到档案或数据库。相反的过程又称为反序列化。</li></ul><a id="more"></a><h1 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h1><p>在说序列化之前，先简单说说字节序。<br>计算机硬件有两种储存数据的方式，大端字节序、小端字节序，</p><p>大端字节序：高位字节在前，低位字节在后<br>小端字节序：低位字节在前，高位字节在后</p><p>那么，什么时候用大端字节序，什么时候用小端字节序呢？</p><p>一般来说，在网络传输中，我们规定使用大端字节序，当然，如果客户端与服务端约定好，也可以用小端字节序</p><p>而在本机处理的时候，一般是使用小端字节序，同理，你用大端也不是不可以，只是一种规定而已</p><h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><h2 id="什么是XML"><a href="#什么是XML" class="headerlink" title="什么是XML"></a>什么是XML</h2><ol><li>XML指可扩展标记语言</li><li>XML是一种标记语言，类似HTML</li><li>XML的设计宗旨是传输数据，而非显示数据</li><li>XML标签没有被预定义，只需要使用者自行定义标签</li><li>XML被设计为具有自我描述性</li></ol><h2 id="XML的优点"><a href="#XML的优点" class="headerlink" title="XML的优点"></a>XML的优点</h2><ol><li>格式统一，结构清晰</li><li>数据传输方便</li></ol><h2 id="XML的缺点"><a href="#XML的缺点" class="headerlink" title="XML的缺点"></a>XML的缺点</h2><ol><li>XML文件庞大，文件格式复杂，传输占带宽</li><li>需要花费较多的资源和时间用来解析</li></ol><h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><h2 id="什么是JSON"><a href="#什么是JSON" class="headerlink" title="什么是JSON"></a>什么是JSON</h2><p>JSON是一种由道格拉斯·克罗克福特构想设计、轻量级的数据交互语言，以文字为基础，且易于让人阅读。</p><p>JSON数据格式与语言无关，脱胎于JavaScript，但目前很多编程语言都支持JSON格式数据的生成和解析。</p><p>JSON构建于两种结构：</p><ol><li>对象（object）：一个对象包含一系列非排序的键值对，一个对象以<code>{</code>开始，并以<code>}</code>结束。每个键值对之间用<code>,</code>分隔</li><li>数组（array）：一个数组是一个值的集合，一个数组以<code>{</code>开始，并以<code>}</code>结束，值之间使用<code>,</code>分隔</li></ol><h2 id="JSON的优点"><a href="#JSON的优点" class="headerlink" title="JSON的优点"></a>JSON的优点</h2><ol><li>数据格式简单，易于读写和维护</li><li>易于解析</li><li>占用带宽小</li><li>轻量级的数据交换格式</li></ol><h1 id="XML与JSON相比"><a href="#XML与JSON相比" class="headerlink" title="XML与JSON相比"></a>XML与JSON相比</h1><ol><li>两者的可读性、扩展性都不错</li><li>两者都拥有丰富的解析手段</li><li>在解析上，XML要占用更多的资源及时间，而JSON的解析速度更快</li><li>在传输速度上，JSON速度远超于XML</li><li>在数据体积上，XML所占体积比JSON更大</li><li>JSON更加轻量级</li></ol><h1 id="Protocol-Buffer"><a href="#Protocol-Buffer" class="headerlink" title="Protocol Buffer"></a>Protocol Buffer</h1><h2 id="什么是Protocol-Buffer"><a href="#什么是Protocol-Buffer" class="headerlink" title="什么是Protocol Buffer"></a>什么是Protocol Buffer</h2><p>Protocol Buffer是Google出品的一款结构化数据的数据存储格式</p><p>通过将结构化的数据序列化，从而实现数据存储、RPC数据交换的功能，适用于传输数据量大和网络环境不稳定的数据存储，RPC数据交换的场景</p><h2 id="Protocol-Buffer的优点"><a href="#Protocol-Buffer的优点" class="headerlink" title="Protocol Buffer的优点"></a>Protocol Buffer的优点</h2><ol><li>轻量级</li><li>速度快</li><li>易于维护</li></ol><h2 id="Protocol-Buffer的缺点"><a href="#Protocol-Buffer的缺点" class="headerlink" title="Protocol Buffer的缺点"></a>Protocol Buffer的缺点</h2><ol><li>不适用于基于文本的标记文档建模</li><li>自解释性差，以二进制数据流方式存储，需要通过.proto文件才能了解到数据结构</li></ol><h2 id="Protocol-Buffer相比于XML、JSON"><a href="#Protocol-Buffer相比于XML、JSON" class="headerlink" title="Protocol Buffer相比于XML、JSON"></a>Protocol Buffer相比于XML、JSON</h2><ol><li>在传输速度、文件大小上，Protocol Buffers更加轻量级，速度更快</li><li>在可读性上，如果不使用.proto文件，Protocol Buffers不可读</li><li>在使用上，Protocol Buffers比起JSON、XML稍显麻烦，需要先用Protocol写好并编译后，放到项目目录中</li></ol><p>以上三种序列化，都是可以用来做网络传输的，那么按照开头我们所说的字节序规定，可以得出，这三者都是使用的大端字节序</p><h1 id="Serializable和Parcelable"><a href="#Serializable和Parcelable" class="headerlink" title="Serializable和Parcelable"></a>Serializable和Parcelable</h1><p>作为一名Android开发者，对于Serializable的了解确实不足，请允许我对照着Android提供的序列化接口Parcelable一起说。</p><h2 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h2><p>作为Java默认的序列化接口，使用起来非常方便，只需要实现Serializable接口，并添加一个serialVersionUID即可实现默认的序列化过程</p><p>通过Serializable方式来实现对象的序列化也很简单，只需要使用ObjectOutputStrean和ObjectInputStream即可：</p><pre><code>//序列化过程User user = new UserObjectOutputStream out = new ObjectOutpuStream)        new FileOutputStream(&quot;cache.txt&quot;));    out.writeObject(user);    out.close();//反序列化过程ObjectInputStream in = new ObjectInputStream(            new FileInputStream(&quot;cache.txt&quot;));User user = (User)in.readObject();in.close();</code></pre><p>序列化更核心的内容在writeObject里，这里就不再展开说了。</p><p>Serializable序列化主要使用反射和ObjectOutputStream实现序列化，众所周知，反射是影响效率的</p><p>值得一提的是，在JVM中，规定字节序是用大端字节序，不出意外的话，Serializable也是使用的大端字节序</p><h2 id="Parcelable"><a href="#Parcelable" class="headerlink" title="Parcelable"></a>Parcelable</h2><p>相比于Serializable，Android提供了一个效率更高的序列化接口：Parcelable。<br>为什么说Parcelable效率更高呢，因为Parcelable实现原理是将一个完整的对象进行分解，而分解后每一部分都是Intent所支持的数据类型。不过，Parcelable效率更高很大一部分原因是因为Serializable是通过反射实现，这里就不举例实现Parcelable序列化了。</p><h1 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h1><ol><li><a href="https://zh.wikipedia.org/zh-hans/%E5%BA%8F%E5%88%97%E5%8C%96" target="_blank" rel="noopener">维基百科</a></li><li><a href="http://www.cnblogs.com/SanMaoSpace/p/3139186.html" target="_blank" rel="noopener">JSON与XML的区别</a></li><li><a href="https://juejin.im/post/595eefcb5188250da205efbe" target="_blank" rel="noopener">快来看看 Google 出品的 Protocol Buffer，别只会用 JSON 和 XML 了</a></li><li><a href="https://developers.google.com/protocol-buffers/docs/pythontutorial" target="_blank" rel="noopener">Protocol Buffer官网</a></li><li><a href="https://www.jianshu.com/p/a60b609ec7e7" target="_blank" rel="noopener">序列化Serializable和Parcelable的理解和区别</a></li><li><a href="http://intheworld.win/2016/12/04/java%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90/" target="_blank" rel="noopener">Java的序列化实现解析</a></li><li><a href="http://blog.csdn.net/XiyouLinux_Kangyijie/article/details/72991235" target="_blank" rel="noopener">数据传输时的字节序</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;序列化（serialization）在计算机科学的资料处理中，是指将数据结构或物件状态转换成可取用格式（例如存成档案，存于缓冲，或经由网络中传送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始物件相同语义的副本。对于许多物件，像是使用大量参照的复杂物件，这种序列化重建的过程并不容易。面向对象中的物件序列化，并不概括之前原始物件所关联的函式。这种过程也称为物件编组（marshalling）。从一系列字节提取数据结构的反向操作，是反序列化（也称为解编组, deserialization, unmarshalling）。 &lt;/p&gt;
&lt;p&gt;序列化在计算机科学中通常有以下定义:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对同步控制而言，表示强制在同一时间内进行单一存取。&lt;/li&gt;
&lt;li&gt;在数据储存与传送的部分是指将一个对象存储至一个储存媒介，例如档案或是记亿体缓冲等，或者透过网络传送资料时进行编码的过程，可以是字节或是XML等格式。而字节的或XML编码格式可以还原完全相等的对象。这程序被应用在不同应用程序之间传送对象，以及服务器将对象储存到档案或数据库。相反的过程又称为反序列化。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="基础" scheme="http://blog.rokudol.cn/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="基础" scheme="http://blog.rokudol.cn/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>RecyclerView的基本使用与进阶（三）</title>
    <link href="http://blog.rokudol.cn/RecyclerView%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E4%B8%8E%E8%BF%9B%E9%98%B6%EF%BC%88%E4%B8%89%EF%BC%89md.html"/>
    <id>http://blog.rokudol.cn/RecyclerView的基本使用与进阶（三）md.html</id>
    <published>2017-08-08T06:42:01.000Z</published>
    <updated>2018-04-07T02:37:46.199Z</updated>
    
    <content type="html"><![CDATA[<p>回头看看自己的博客发现RecyclerVer系列还没写完。。完全忘记了。。。来补上，本篇分为两个部分：</p><p><em>第一部分：</em> DefaultItemAnimator源码解析，即Google官方提供的item动画源码</p><p><em>第二部分：</em> 如何写一个自己的item动画<br>本篇就不贴效果图了，想看效果不妨自己去试试，我一直认为要学会怎么熟练的使用一个东西，就得了解这个东西是怎么运作的，不多说废话，正式开始：</p><a id="more"></a><h1 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h1><p>打开源码可以看到该类继承自SimpleItemAnimator，再点开这个类看看，发现继承自RecyclerView.ItemAnimator，看来是SimpleItemAnimator对rv的动画进行了进一步的封装，最后DefaultItemAnimator再来具体实现想要的动画，这里不详谈SimpleItemAnimator，只看Google是怎么实现rv的item动画的，说一下涉及到的几个方法的作用：</p><h2 id="方法解读"><a href="#方法解读" class="headerlink" title="方法解读"></a>方法解读</h2><ol><li>animateAdd(final RecyclerView.ViewHolder holder)：添加item时调用的动画，用adapter.notifyItemInster()时会调用该方法，若需要定制自己的动画，需要将返回值更改为true</li><li>animateRemove(final RecyclerView.ViewHolder holder)：删除item时调用的动画，用adapter.notifyItemRemove()时会调用该方法，若需要定制自己的动画，需要将返回值更改为true</li><li>animateMove(final RecyclerView.ViewHolder holder, int fromX, int fromY, int toX, int toY)：item移动时调用的动画，再说明白点就是添加、删除item时调用的方法，参数看名字就知道啥意思，不多做解释，若需要定制自己的动画，需要将该返回值更改为true</li><li>animateChange(RecyclerView.ViewHolder oldHolder, RecyclerView.ViewHolder newHolder, int fromX, int fromY, int toX, int toY)：item接收到notifyItemChanged()或者notifyItemRangeChanged()调用的方法，同样，若需要定制自己的动画，需要将该返回值更改为true</li><li>endAnimation(RecyclerView.ViewHolder item)：动画结束时调用的方法</li><li>canReuseUpdatedViewHolder(RecyclerView.ViewHolder viewHolder, List<object> payloads):当item改变时调用该方法itemAnimator可以决定是否要重复使用相同的ViewHolder进行动画。</object></li><li>isRunning()：判断是否有动画正在执行</li><li><p>runPendingAnimations()：当有等待动画时调用</p><h2 id="变量解读"><a href="#变量解读" class="headerlink" title="变量解读"></a>变量解读</h2><p> private ArrayList&lt;RecyclerView.ViewHolder&gt; mPendingRemovals = new ArrayList&lt;&gt;();<br> private ArrayList&lt;RecyclerView.ViewHolder&gt; mPendingAdditions = new ArrayList&lt;&gt;();<br> private ArrayList<moveinfo> mPendingMoves = new ArrayList&lt;&gt;();<br> private ArrayList<changeinfo> mPendingChanges = new ArrayList&lt;&gt;();</changeinfo></moveinfo></p><p> ArrayList&lt;RecyclerView.ViewHolder&gt; mAddAnimations = new ArrayList&lt;&gt;();<br> ArrayList&lt;RecyclerView.ViewHolder&gt; mMoveAnimations = new ArrayList&lt;&gt;();<br> ArrayList&lt;RecyclerView.ViewHolder&gt; mRemoveAnimations = new ArrayList&lt;&gt;();<br> ArrayList&lt;RecyclerView.ViewHolder&gt; mChangeAnimations = new ArrayList&lt;&gt;();</p><p> ArrayList&lt;ArrayList&lt;RecyclerView.ViewHolder&gt;&gt; mAdditionsList = new ArrayList&lt;&gt;();<br> ArrayList&lt;ArrayList<moveinfo>&gt; mMovesList = new ArrayList&lt;&gt;();<br> ArrayList&lt;ArrayList<changeinfo>&gt; mChangesList = new ArrayList&lt;&gt;();<br>能看到Google用了这么多的集合，具体作用是什么？很简单，看看runPendingAnimations()方法，我们可以得出一个结论：动画时有可能存在等待情况的！也就是说，当上一个动画还未执行完成的时候，下一个动画需要等待上一个动画执行完成后才可以执行，那万一等待了多个动画咋整，用集合保存起来呀，可是增加、删除、移动、刷新就四个动画，为啥有这么多集合，仔细看看前8个，是不是两两一组的，作用是什么呢？拿Add这组解释一下：可以看到Add这组有两个集合，mPendingAdditions和mAddAnimations，前者是等待处理的动画集合，后者就是处理中的动画集合，其他几个一样。那剩下三个是干嘛的？后面用到的时候再解释</changeinfo></moveinfo></p></li></ol><h2 id="isRunning"><a href="#isRunning" class="headerlink" title="isRunning()"></a>isRunning()</h2><pre><code>@Overridepublic boolean isRunning() {    return (!mPendingAdditions.isEmpty() ||            !mPendingChanges.isEmpty() ||            !mPendingMoves.isEmpty() ||            !mPendingRemovals.isEmpty() ||            !mMoveAnimations.isEmpty() ||            !mRemoveAnimations.isEmpty() ||            !mAddAnimations.isEmpty() ||            !mChangeAnimations.isEmpty() ||            !mMovesList.isEmpty() ||            !mAdditionsList.isEmpty() ||            !mChangesList.isEmpty());}</code></pre><p>这个似乎没啥好解释的。。只要其中一个动画集合不为空，则返回true，即：还有动画正在执行或需要执行</p><h2 id="animateAdd"><a href="#animateAdd" class="headerlink" title="animateAdd()"></a>animateAdd()</h2><pre><code>@Overridepublic boolean animateAdd(final RecyclerView.ViewHolder holder) {    resetAnimation(holder);    ViewCompat.setAlpha(holder.itemView, 0);    mPendingAdditions.add(holder);    return true;}</code></pre><p>一行一行的来解读，首先是resetAnimation(holder)，这个方法是用来干嘛的，点进去看看：</p><pre><code>private void resetAnimation(RecyclerView.ViewHolder holder) {    AnimatorCompatHelper.clearInterpolator(holder.itemView);    endAnimation(holder);}</code></pre><p>第一个方法是用来干嘛的？层层抽丝剥茧，终于找到这样一段：</p><pre><code> @Override    public void clearInterpolator(View view) {        if (mDefaultInterpolator == null) {            mDefaultInterpolator = new ValueAnimator().getInterpolator();        }        view.animate().setInterpolator(mDefaultInterpolator);    }}</code></pre><p>看到了吗！view.animate().setInterpolator()，这是拿来干嘛的？</p><p>官方解释：</p><p>Sets the interpolator for the underlying animator that animates the requested properties.</p><p>翻译一下：为底层动画设置内插器，使动态化请求的属性。</p><p>具体作用是啥？就是用来修饰动画效果的，点到即止，不多做展开，来看看下一句</p><p>endAnimation()，调用结束动画</p><pre><code>@Override    public void endAnimation(RecyclerView.ViewHolder item) {        final View view = item.itemView;        ViewCompat.animate(view).cancel();        ...        for (int i = mAdditionsList.size() - 1; i &gt;= 0; i--) {            ArrayList&lt;RecyclerView.ViewHolder&gt; additions = mAdditionsList.get(i);            if (additions.remove(item)) {                ViewCompat.setAlpha(view, 1);                dispatchAddFinished(item);                if (additions.isEmpty()) {                    mAdditionsList.remove(i);                }            }        }        ...        }</code></pre><p>这一段就是将动画停止掉，将整个animateAdd方法连起来看看：</p><ol><li>开始执行添加动画时，重置添加相关的动画</li><li>将需要执行添加动画的itemView的alpha值设置为0，即设置为不可见</li><li><p>将需要执行添加动画的itemView添加进等待处理添加动画的集合中<br>这时候就会执行runPendingAnimations()方法：</p><h2 id="runPendingAnimations"><a href="#runPendingAnimations" class="headerlink" title="runPendingAnimations()"></a>runPendingAnimations()</h2><p> public void runPendingAnimations() {</p><pre><code>    boolean removalsPending = !mPendingRemovals.isEmpty();//如果待执行的删除动画为空时    boolean movesPending = !mPendingMoves.isEmpty();//如果待执行的移动动画为空时    boolean changesPending = !mPendingChanges.isEmpty();//如果待执行的刷新动画为空时    boolean additionsPending = !mPendingAdditions.isEmpty();//如果待执行的添加动画为空时    if (!removalsPending &amp;&amp; !movesPending &amp;&amp; !additionsPending &amp;&amp; !changesPending) {        // 没有动画需要执行时        return;    }    // 首先，执行删除动画    for (RecyclerView.ViewHolder holder : mPendingRemovals) {        animateRemoveImpl(holder);    }    mPendingRemovals.clear();    // 然后执行移动动画    if (movesPending) {        final ArrayList&lt;MoveInfo&gt; moves = new ArrayList&lt;&gt;();        moves.addAll(mPendingMoves);        mMovesList.add(moves);        mPendingMoves.clear();        Runnable mover = new Runnable() {            @Override            public void run() {            //将所有的删除动画放在一块一起执行                for (MoveInfo moveInfo : moves) {                    animateMoveImpl(moveInfo.holder, moveInfo.fromX, moveInfo.fromY,                            moveInfo.toX, moveInfo.toY);                }                //执行完成后清空                moves.clear();                mMovesList.remove(moves);            }        };        //如果有待执行的删除动画        if (removalsPending) {            View view = moves.get(0).holder.itemView;            ViewCompat.postOnAnimationDelayed(view, mover, getRemoveDuration());        } else {            mover.run();        }    }    // 执行更新动画，与移动动画并行执行    if (changesPending) {        final ArrayList&lt;ChangeInfo&gt; changes = new ArrayList&lt;&gt;();        changes.addAll(mPendingChanges);        mChangesList.add(changes);        mPendingChanges.clear();        Runnable changer = new Runnable() {            @Override            public void run() {            //将所有待执行的更新动画一块执行                for (ChangeInfo change : changes) {                    animateChangeImpl(change);                }                //执行完成后清空                changes.clear();                mChangesList.remove(changes);            }        };        //如果有待执行的删除动画        if (removalsPending) {            RecyclerView.ViewHolder holder = changes.get(0).oldHolder;            ViewCompat.postOnAnimationDelayed(holder.itemView, changer, getRemoveDuration());        } else {            changer.run();        }    }    // 执行添加动画    if (additionsPending) {        final ArrayList&lt;RecyclerView.ViewHolder&gt; additions = new ArrayList&lt;&gt;();        additions.addAll(mPendingAdditions);        mAdditionsList.add(additions);        mPendingAdditions.clear();        Runnable adder = new Runnable() {            @Override            public void run() {            //将所有添加动画放在一块执行                for (RecyclerView.ViewHolder holder : additions) {                    animateAddImpl(holder);                }                //动画执行完成后清空                additions.clear();                mAdditionsList.remove(additions);            }        };        //如果删除、移动、更新动画某一个为空时，获取每一个动画的持续时间        if (removalsPending || movesPending || changesPending) {            long removeDuration = removalsPending ? getRemoveDuration() : 0;            long moveDuration = movesPending ? getMoveDuration() : 0;            long changeDuration = changesPending ? getChangeDuration() : 0;            //添加动画的持续时间 = =删除动画持续时间+(移动动画或更新动画持续时间最长的一个)            long totalDelay = removeDuration + Math.max(moveDuration, changeDuration);            View view = additions.get(0).itemView;            ViewCompat.postOnAnimationDelayed(view, adder, totalDelay);        } else {            adder.run();        }    }}</code></pre></li></ol><p>以上就是处理待执行动画的所有步骤，有详细注释就不做解释了，细心的同学可能有注意到，添加、删除、移动、更新动画都有一个impl方法，这个方法里就是具体的动画！先来看看添加动画：</p><h2 id="animateAddImpl"><a href="#animateAddImpl" class="headerlink" title="animateAddImpl"></a>animateAddImpl</h2><pre><code>void animateAddImpl(final RecyclerView.ViewHolder holder) {    final View view = holder.itemView;    final ViewPropertyAnimatorCompat animation = ViewCompat.animate(view);    mAddAnimations.add(holder);    animation.alpha(1).setDuration(getAddDuration()).            setListener(new VpaListenerAdapter() {                //动画开始时，调用dispatchAddStarting，即通知可以开始动画了！                @Override                public void onAnimationStart(View view) {                    dispatchAddStarting(holder);                }                @Override                public void onAnimationCancel(View view) {                    ViewCompat.setAlpha(view, 1);                }                //动画结束时，清空动画的监听，通知动画已结束，将处理中的动画集合移除当前这一个，如果当前已经没有动画在执行了，结束所有动画                @Override                public void onAnimationEnd(View view) {                    animation.setListener(null);                    dispatchAddFinished(holder);                    mAddAnimations.remove(holder);                    dispatchFinishedWhenDone();                }            }).start();}</code></pre><p>简单讲讲animateMove：</p><h2 id="animateMove"><a href="#animateMove" class="headerlink" title="animateMove()"></a>animateMove()</h2><pre><code>@Override    public boolean animateMove(final RecyclerView.ViewHolder holder, int fromX, int fromY,                               int toX, int toY) {        final View view = holder.itemView;        fromX += ViewCompat.getTranslationX(holder.itemView);        fromY += ViewCompat.getTranslationY(holder.itemView);        resetAnimation(holder);        int deltaX = toX - fromX;        int deltaY = toY - fromY;        if (deltaX == 0 &amp;&amp; deltaY == 0) {            dispatchMoveFinished(holder);            return false;        }        if (deltaX != 0) {            ViewCompat.setTranslationX(view, -deltaX);        }        if (deltaY != 0) {            ViewCompat.setTranslationY(view, -deltaY);        }        mPendingMoves.add(new MoveInfo(holder, fromX, fromY, toX, toY));        return true;    }</code></pre><p>其实很好理解，就说一下deltaX和deltaY，Google这样计算的目的就是为了在上一个item在移出的时候，当前这个item不会立即移动到当前上一个item的位置。</p><p>其他几个动画类似，就不做解释了，在这里也可以看出，具体是用的什么动画，动画时什么效果，都是在animatexxximpl中执行的，如果想要定制自己的动画，直接改这几个方法就可以了</p><p>接下来讲讲如何定制属于自己的item动画</p><h1 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h1><p>前面说了，动画的具体实现都是在各个animateXXXImpl()中，那么要定制属于我们自己item动画，只需要更改animateXXXImpl()方法就可以了，那么我们先来做一个自己的添加动画</p><h2 id="animateRemoveImpl"><a href="#animateRemoveImpl" class="headerlink" title="animateRemoveImpl()"></a>animateRemoveImpl()</h2><p>期望效果：这个item删除时，逐渐透明且慢慢缩小<br>很简单的效果，我们只需要设置alpha，scaleX和scaleY就可以了：</p><pre><code>private void animateRemoveImpl(final RecyclerView.ViewHolder holder) {    final View view = holder.itemView;    final ViewPropertyAnimatorCompat animation = ViewCompat.animate(view);    mRemoveAnimations.add(holder);    animation.setDuration(getRemoveDuration())            .alpha(0).scaleY(0).scaleX(0).setListener(new VpaListenerAdapter() {        @Override        public void onAnimationStart(View view) {            dispatchRemoveStarting(holder);        }        @Override        public void onAnimationEnd(View view) {            animation.setListener(null);            ViewCompat.setAlpha(view, 1);            ViewCompat.setScaleY(view, 1);            ViewCompat.setScaleX(view, 1);            dispatchRemoveFinished(holder);            mRemoveAnimations.remove(holder);            dispatchFinishedWhenDone();        }    }).start();}</code></pre><h2 id="animateAddImpl-1"><a href="#animateAddImpl-1" class="headerlink" title="animateAddImpl()"></a>animateAddImpl()</h2><p>期望效果：从透明变为可见，并从小拉伸到正常大小<br>其实就是跟remove反过来了而已，来看看代码：</p><pre><code>void animateAddImpl(final RecyclerView.ViewHolder holder) {        final View view = holder.itemView;        final ViewPropertyAnimatorCompat animation = ViewCompat.animate(view);        mAddAnimations.add(holder);        animation.alpha(1).scaleX(1).scaleY(1).setDuration(getAddDuration()).                setListener(new VpaListenerAdapter() {                    @Override                    public void onAnimationStart(View view) {                        dispatchAddStarting(holder);                    }                @Override                public void onAnimationCancel(View view) {                    ViewCompat.setScaleX(view, 1);                    ViewCompat.setScaleY(view, 1);                    ViewCompat.setAlpha(view, 1);                }                @Override                public void onAnimationEnd(View view) {                    animation.setListener(null);                    dispatchAddFinished(holder);                    mAddAnimations.remove(holder);                    dispatchFinishedWhenDone();                }            }).start();}</code></pre><p>来看看效果：</p><p><img src="/images/rv3Add1.gif" alt=""></p><p>添加Item的动画跟想象的不一样啊！回头看看animateAdd()：</p><pre><code>@Overridepublic boolean animateAdd(final RecyclerView.ViewHolder holder) {    resetAnimation(holder);    ViewCompat.setAlpha(holder.itemView, 0);    mPendingAdditions.add(holder);    return true;}</code></pre><p>这里还开始动画时只设置了alpha为透明，并没有把item缩小，那么改一下：</p><pre><code>@Overridepublic boolean animateAdd(final RecyclerView.ViewHolder holder) {    resetAnimation(holder);    ViewCompat.setAlpha(holder.itemView, 0);    ViewCompat.setScaleX(holder.itemView, 0);    ViewCompat.setScaleY(holder.itemView, 0);    mPendingAdditions.add(holder);    return true;}</code></pre><p>再来看看效果：</p><p><img src="/images/rv3Add2.gif" alt=""></p><p>这下对了，快速连续点几下试试看呢：<br>为啥前几个item都是透明的啊！刷新看看，又正常显示了！咋回事，想想最开始说的animateAdd()，我们在添加动画之前，先重置了动画，也就是resetAnimation()，点进去找到endAnimation()，看看添加相关的代码块：</p><pre><code>for (int i = mAdditionsList.size() - 1; i &gt;= 0; i--) {            ArrayList&lt;RecyclerView.ViewHolder&gt; additions = mAdditionsList.get(i);            if (additions.remove(item)) {                ViewCompat.setAlpha(view, 1);                dispatchAddFinished(item);                if (additions.isEmpty()) {                    mAdditionsList.remove(i);                }            }</code></pre><p>这下原因明了了，在我们快速点击添加时，会先执行这里面的代码，而这里只设置了alpha值，修改一下：</p><pre><code>for (int i = mAdditionsList.size() - 1; i &gt;= 0; i--) {            ArrayList&lt;RecyclerView.ViewHolder&gt; additions = mAdditionsList.get(i);            if (additions.remove(item)) {                ViewCompat.setAlpha(view, 1);                ViewCompat.setScaleY(view,1);                ViewCompat.setScaleX(view,1);                dispatchAddFinished(item);                if (additions.isEmpty()) {                    mAdditionsList.remove(i);                }            }</code></pre><p>再来看看效果：</p><p><img src="/images/rv3Add3.gif" alt=""></p><p>完美</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>只讲了添加删除的动画，move和change都没有改动，篇幅太长就不做演示了，有兴趣可以自己尝试一下，不过难度最大的还是move，change的动画，毕竟要计算坐标，相对添加删除来说要难一点点，虽然也差不了多少，本篇到此结束，文中如有错误的地方，还请指出，谢谢！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;回头看看自己的博客发现RecyclerVer系列还没写完。。完全忘记了。。。来补上，本篇分为两个部分：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;第一部分：&lt;/em&gt; DefaultItemAnimator源码解析，即Google官方提供的item动画源码&lt;/p&gt;
&lt;p&gt;&lt;em&gt;第二部分：&lt;/em&gt; 如何写一个自己的item动画&lt;br&gt;本篇就不贴效果图了，想看效果不妨自己去试试，我一直认为要学会怎么熟练的使用一个东西，就得了解这个东西是怎么运作的，不多说废话，正式开始：&lt;/p&gt;
    
    </summary>
    
      <category term="RecyclerView" scheme="http://blog.rokudol.cn/categories/RecyclerView/"/>
    
    
      <category term="Android" scheme="http://blog.rokudol.cn/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>自定义view---强大的密码输入框</title>
    <link href="http://blog.rokudol.cn/%E8%87%AA%E5%AE%9A%E4%B9%89view---%E5%BC%BA%E5%A4%A7%E7%9A%84%E5%AF%86%E7%A0%81%E8%BE%93%E5%85%A5%E6%A1%86.html"/>
    <id>http://blog.rokudol.cn/自定义view---强大的密码输入框.html</id>
    <published>2017-08-08T06:42:01.000Z</published>
    <updated>2018-04-07T02:37:46.200Z</updated>
    
    <content type="html"><![CDATA[<p>我司之前有个需求，要求类似支付宝那样的密码支付，产品要求输入的当前字符需要是明文密码，1s后转换为圆点，原本想网上那么多密码输入框，肯定没问题，结果UI一出图就懵逼了，翻遍了各个角落，都找不到类似的密码输入框，没办法，自己写吧。<br>使用方法，在gradle中添加：compile ‘com.rokudoll:PswText:1.0.0’即可使用<br>当然绘制思路参照了其他大佬的思路，言归正传，先来看看效果图：<br><img src="/images/Renderings.png" alt=""><br><a id="more"></a></p><h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><p>拿到效果图，再结合产品的要求，整理出以下要求：<br>1、类似EditText的password模式，输入密码时，输入的当前密码为明文，而之前的密码变为圆点，1s后当前密码也变为圆点<br>2、整体密码框为一个颜色，而已输入或当前输入密码位置的密码框为另一个颜色<br>3、有阴影</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>自定义view的流程就不再赘述了，不太清楚的可以去看看鸿洋和郭林的教程，先写好自定义属性，按照之前分析的结果以及自己的一点想法，为了更方便的使用，就有了以下的自定义属性，目前没有使用枚举，全部都是以boolean值来规定使用哪种模式，不过之后会换成枚举，那么先来看看有哪些自定义属性：</p><h2 id="attrs"><a href="#attrs" class="headerlink" title="attrs"></a>attrs</h2><table><thead><tr><th>属性名</th><th style="text-align:right">值</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td>pswLength</td><td style="text-align:right">integer</td><td style="text-align:center">规定密码长度，默认为6</td></tr><tr><td>delayTime</td><td style="text-align:right">integer</td><td style="text-align:center">延迟绘制密码圆点的时间 默认1000,1000=1s</td></tr><tr><td>borderColor</td><td style="text-align:right">color</td><td style="text-align:center">初始化密码框颜色</td></tr><tr><td>pswColor</td><td style="text-align:right">color</td><td style="text-align:center">密码颜色</td></tr><tr><td>inputBorder_color</td><td style="text-align:right">color</td><td style="text-align:center">输入时密码框颜色</td></tr><tr><td>borderShadow_color</td><td style="text-align:right">color</td><td style="text-align:center">输入时密码框阴影颜色</td></tr><tr><td>psw_textSize</td><td style="text-align:right">sp</td><td style="text-align:center">明文密码大小</td></tr><tr><td>borderRadius</td><td style="text-align:right">dp</td><td style="text-align:center">不使用图片时，密码框圆角大小</td></tr><tr><td>borderImg</td><td style="text-align:right">drawable</td><td style="text-align:center">密码框图片</td></tr><tr><td>inputBorderImg</td><td style="text-align:right">drawable</td><td style="text-align:center">输入时变化的密码框图片</td></tr><tr><td>isDrawBorderImg</td><td style="text-align:right">boolean</td><td style="text-align:center">是否使用图片绘制密码框，为true时设置borderImg、inputBorderImg才有效，默认为false</td></tr><tr><td>isShowTextPsw</td><td style="text-align:right">boolean</td><td style="text-align:center">按下back键时是否需要绘制当前位置的明文密码，默认为false</td></tr><tr><td>isShowBorderShadow</td><td style="text-align:right">boolean</td><td style="text-align:center">输入密码时是否需要绘制阴影,为true时设置borderShadow_color才有效，默认为false</td></tr><tr><td>clearTextPsw</td><td style="text-align:right">boolean</td><td style="text-align:center">是否只绘制明文密码，默认为false</td></tr><tr><td>darkPsw</td><td style="text-align:right">boolean</td><td style="text-align:center">是否只绘制圆点，默认为false</td></tr><tr><td>isChangeBorder</td><td style="text-align:right">boolean</td><td style="text-align:center">是否在输入密码时不更改密码框颜色，默认为false</td></tr></tbody></table><p>设置好自定义属性后，就开始实现这个自定义控件了！首先肯定是计算宽高</p><h2 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure"></a>onMeasure</h2><p>作为一个数学很差的人，计算这个的过程确实是比较糟心的。。直接看图吧<br><img src="/images/pswTextDraft.png" alt=""><br>图中说明两处：<br>1、spacingWidth：为什么在宽度已知的情况下，spacingWidth = borderWidth / 4：<br>    很简单，因为用边框的宽度除以4得到的大小刚好是能让我接受的大小，且在pswLength = 7、8、9、10的时候，宽度也比较合适，说白了就是一点点凑出来的<br>2、borderWidth：为什么在宽度已知的情况下，borderWidth = (width <em> 4) / ((5 </em> pswLength) - 1)，<br>这个其实很好理解，当宽度已知的时候，borderWidth = width / 6 - spacingWidth，即宽度除以6减去一个间隙的宽度就等于一个边框的宽度，而间隙的宽度 = borderWidth /4，那么我们换算成一个方程式来看看，就一目了然了,如果这个方程式还看不懂，那就去请教一下初中数学老师吧。。<br><img src="/images/pswTextEquation.png" alt=""></p><p>来看看完整代码：</p><pre><code>@Override    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {        int widthSpec = MeasureSpec.getMode(widthMeasureSpec);        int widthSize = MeasureSpec.getSize(widthMeasureSpec);        int heightSpec = MeasureSpec.getMode(heightMeasureSpec);        int heightSize = MeasureSpec.getSize(heightMeasureSpec);        if (widthSpec == MeasureSpec.AT_MOST) {            if (heightSpec != MeasureSpec.AT_MOST) {//高度已知但宽度未知时                spacingWidth = heightSize / 4;                widthSize = (heightSize * pswLength) + (spacingWidth * (pswLength - 1));                borderWidth = heightSize;            } else {//宽度，高度都未知时                widthSize = (borderWidth * pswLength) + (spacingWidth * (pswLength - 1));                heightSize = (int) (borderWidth + ((borderPaint.getStrokeWidth()) * 2));            }        } else {            //宽度已知但高度未知            if (heightSpec == MeasureSpec.AT_MOST) {                borderWidth = (widthSize * 4) / (5 * pswLength);                spacingWidth = borderWidth / 4;                heightSize = (int) (borderWidth + ((borderPaint.getStrokeWidth()) * 2));            }        }        setMeasuredDimension(widthSize, heightSize);    }</code></pre><p>解释一下为什么高度要加上borderPaint.getStrokeWidth()<em>2，很简单，如果直接取每个密码框的宽度作为高度的话，会出现密码框上下两根线绘制不完全的问题，因为画笔的宽度也是占了一定的大小的，所以我们在绘制高度时要留足够的高度来绘制整个view，为什么是</em>2呢？因为上下两根线。。当然要加两次，所以是乘以2</p><p>按这种算法绘制出的view，其实右边还多了一个spacingWidth的宽度，因为我们给每一个边框都减去了一个spacingWidth的宽度，所以会多出一个spacingWidth的宽度，不过并不影响，我们可以在onDraw里把每一个密码框往右移0.5个spacingWidth的宽度，这样左右都空出了一小段空隙，视觉效果上也好看一点，直接来看看onDraw</p><h2 id="onDraw"><a href="#onDraw" class="headerlink" title="onDraw"></a>onDraw</h2><h3 id="绘制pswLength数量个密码框"><a href="#绘制pswLength数量个密码框" class="headerlink" title="绘制pswLength数量个密码框"></a>绘制pswLength数量个密码框</h3><p>先说说思路，我们用for循环的方式，循环绘制出pswLength个密码框，用canvas.drawRoundRect绘制密码框，如果使用图片的话，就绘制图片，那么来看看canvas.drawRoundRect需要传递的参数:</p><pre><code>drawRoundRect(RectF rect, float rx, float ry, Paint paint)</code></pre><p>rect：RectF对象，边框的具体坐标<br>rx,ry：圆角x,y轴的半径<br>paint：画笔<br>那我们先来计算边框的具体坐标，来看看草稿：<br><img src="/images/pswTextonDraw.png" alt=""><br>没错，这草稿就是这么low，数学差。。就是这么心酸，不过已经可以看出规律，前面说过，我们是用for循环的方式循环绘制出各个密码框，那么总结一下：<br>top =  0 + (borderPaint.getStrokeWidth())<br>bottom = height - (borderPaint.getStrokeWidth())<br>left = i <em> (borderWidth + spacingWidth)<br>right = borderWidth + i </em> (borderWidth + spacingWidth)<br>      = ((i + 1) <em> borderWidth) + (i </em> spacingWidth)</p><p>为什么top加上了borderPaint.getStrokeWidth()，而bottom又减去了borderPaint.getStrokeWidth()？</p><p>还记得我们在onMeasure处计算高度时，增加了borderPaint.getStrokeWidth()*2吗，我们的密码框在绘制时，为了把整个view往下移一个画笔宽度的位置，就需要在top出加上一个画笔宽度的大小。<br>而为什么bottom又要减去一个画笔宽度呢？仔细想想看，我们的bottom是用view的高度-一个画笔的宽度，而height是在边框的宽度基础上加上了两个画笔的宽度的，减去一个就正好是把整个view往下移了一个画笔的宽度</p><p>但是这样绘制出来的密码框，就像前面提过的，右边会多出一个spacingWidth，所以我们left和right的坐标需要再改进一下:<br>int left = (int) ( (i <em> (borderWidth + spacingWidth)) + (0.5 </em> spacingWidth));<br>int right = (int) (((i + 1) <em> borderWidth) + (i </em> spacingWidth) + (0.5 * spacingWidth));<br>到这里并没有结束，为啥？因为说好的可以用图片来绘制边框，我们还没有实现这一步，不过也很简单，不需要重新计算坐标，直接贴该部分的完整代码：</p><pre><code>private void drawBorder(Canvas canvas, int height) {        Bitmap bitmap = BitmapFactory.decodeResource(getResources(), borderImg);        Rect src = new Rect(0, 0, bitmap.getWidth(), bitmap.getHeight());        for (int i = 0; i &lt; pswLength; i++) {            int left = (int) ( (i * (borderWidth + spacingWidth)) + (0.5 * spacingWidth));            int right = (int) (((i + 1) * borderWidth) + (i * spacingWidth) + (0.5 * spacingWidth));            if (isBorderImg) {                Rect dst = new Rect(left, 0, right, height);                canvas.drawBitmap(bitmap, src, dst, borderPaint);            } else {                borderRectF.set(left, 0, right, height);                canvas.drawRoundRect(borderRectF, borderRadius, borderRadius, borderPaint);            }        }        bitmap.recycle();    }</code></pre><h3 id="只绘制明文密码模式"><a href="#只绘制明文密码模式" class="headerlink" title="只绘制明文密码模式"></a>只绘制明文密码模式</h3><p>这个很简单，就不多做解释了</p><pre><code>private void drawText(Canvas canvas, String num, int i) {    Rect mTextBound = new Rect();    pswTextPaint.getTextBounds(num, 0, num.length(), mTextBound);    Paint.FontMetrics fontMetrics = pswTextPaint.getFontMetrics();    float textX = (float) ((i * (borderWidth + spacingWidth)) + (borderWidth / 2 - mTextBound.width() / 2) + (0.5 * spacingWidth));    float textY = (getMeasuredHeight() - fontMetrics.bottom + fontMetrics.top) / 2 - fontMetrics.top;    if (saveResult != 0 || saveResult &lt; result.size()) {        canvas.drawText(num, textX, textY, pswTextPaint);    }}</code></pre><p>说明一点，为什么在textX最后要加0.5*spacingWidth，因为我们绘制密码框的时候就多增加了这么多的宽度，所以绘制文字也要做同样的操作，同理，绘制圆点时也是一样，后面不多做赘述</p><h3 id="只绘制圆点模式"><a href="#只绘制圆点模式" class="headerlink" title="只绘制圆点模式"></a>只绘制圆点模式</h3><pre><code>for (int i = 0; i &lt; result.size(); i++) {                float circleX = (float) ((i * (borderWidth + spacingWidth)) + (borderWidth / 2)  + (0.6 * spacingWidth));                float circleY = borderWidth / 2;                int left = (int) (i * (borderWidth + spacingWidth) + (0.5 * spacingWidth));                int right = (int) (((i + 1) * borderWidth) + (i * spacingWidth) + (0.5 * spacingWidth));                drawBitmapOrBorder(canvas, left, right, height);                canvas.drawCircle(circleX, circleY, dotRadius, pswDotPaint);            }</code></pre><h3 id="绘制输入密码时密码框变换样式："><a href="#绘制输入密码时密码框变换样式：" class="headerlink" title="绘制输入密码时密码框变换样式："></a>绘制输入密码时密码框变换样式：</h3><pre><code>private void drawBitmapOrBorder(Canvas canvas, int left, int right, int height) {    if (isBorderImg) {        Bitmap bitmap = BitmapFactory.decodeResource(getResources(), inputBorderImg);        Rect src = new Rect(0, 0, bitmap.getWidth(), bitmap.getHeight());        Rect dst = new Rect(left, 0, right, height);        canvas.drawBitmap(bitmap, src, dst, inputBorderPaint);        bitmap.recycle();    } else {        borderRectF.set(left, 0, right, height);        canvas.drawRoundRect(borderRectF, borderRadius, borderRadius, inputBorderPaint);    }}</code></pre><h3 id="输入密码时，输入的当前密码为明文，1s后变为圆点模式，即默认模式"><a href="#输入密码时，输入的当前密码为明文，1s后变为圆点模式，即默认模式" class="headerlink" title="输入密码时，输入的当前密码为明文，1s后变为圆点模式，即默认模式"></a>输入密码时，输入的当前密码为明文，1s后变为圆点模式，即默认模式</h3><pre><code>if (invalidated) {                drawDelayCircle(canvas, height, dotRadius);                return;            }            for (int i = 0; i &lt; result.size(); i++) {                //密码明文                String num = result.get(i) + &quot;&quot;;                //圆点坐标                float circleX = (float) (((i - 1) * (borderWidth + spacingWidth)) + (borderWidth / 2) + (0.6 * spacingWidth));                float circleY = borderWidth / 2;                //密码框坐标                int left = (int) (i * (borderWidth + spacingWidth) + (0.5 * spacingWidth));                int right = (int) (((i + 1) * borderWidth) + (i * spacingWidth) + (0.5 * spacingWidth));            drawBitmapOrBorder(canvas, left, right, height);            drawText(canvas, num, i);            //当输入位置 = 输入的长度时，即判断当前绘制的位置是否为当前密码位置，若是则延迟1s后绘制圆点            if (i + 1 == result.size()) {                handler.sendEmptyMessageDelayed(1, delayTime);            }            //若按下back键保存的密码 &gt; 输入的密码长度，则只绘制圆点            //即按下back键时，不绘制明文密码            if (!isShowTextPsw) {                if (saveResult &gt; result.size()) {                    canvas.drawCircle((float) ((i * (borderWidth + spacingWidth)) + (borderWidth / 2 + (0.5 * spacingWidth))), circleY, dotRadius, pswDotPaint);                }            }            //当输入第二个密码时，才开始绘制圆点            if (i &gt;= 1) {                canvas.drawCircle(circleX, circleY, dotRadius, pswDotPaint);            }        }    }</code></pre><p>可能有同学注意到，这里我们计算的圆点坐标跟之前计算的不一样，为什么呢？因为在这里，我们计算的圆点坐标分为两种情况：<br>1、输入密码时，已输入的密码变为圆点，那么我们的圆点坐标就应该是用(i - 1)的方式去计算，这样才能实现输入到第二个密码时，第一个密码变为圆点<br>2、输入密码时，延迟1s后当前明文密码变为圆点，那么圆点坐标就应该是(i + 1)的方式计算</p><h3 id="延迟绘制圆点"><a href="#延迟绘制圆点" class="headerlink" title="延迟绘制圆点"></a>延迟绘制圆点</h3><pre><code>private void drawDelayCircle(Canvas canvas, int height, int dotRadius) {    invalidated = false;    for (int i = 0; i &lt; result.size(); i++) {        float circleX = (float) (((i - 1) * (borderWidth + spacingWidth)) + (borderWidth / 2) + (0.6 * spacingWidth));        float circleY = borderWidth / 2;        int left = (int) (i * (borderWidth + spacingWidth) + (0.5 * spacingWidth));        int right = (int) (((i + 1) * borderWidth) + (i * spacingWidth) + (0.5 * spacingWidth));        canvas.drawCircle(circleX, circleY, dotRadius, pswDotPaint);        drawBitmapOrBorder(canvas, left, right, height);    }    canvas.drawCircle((float) ((float) (((result.size() - 1) * (borderWidth + spacingWidth)) + (borderWidth / 2)) + (0.5 * spacingWidth)),            borderWidth / 2, dotRadius, pswDotPaint);    handler.removeMessages(1);}</code></pre><p>以上就是全部的绘制逻辑，计算坐标这类似乎没什么好解释的，接下来就是自定义键盘，界面不需要我们自己再重新设计，用系统的就好，来看看代码</p><h3 id="键盘"><a href="#键盘" class="headerlink" title="键盘"></a>键盘</h3><pre><code>class NumKeyListener implements OnKeyListener {        @Override        public boolean onKey(View v, int keyCode, KeyEvent event) {            if (event.getAction() == KeyEvent.ACTION_DOWN) {                if (event.isShiftPressed()) {//处理*#等键                    return false;                }                if (keyCode &gt;= KeyEvent.KEYCODE_0 &amp;&amp; keyCode &lt;= KeyEvent.KEYCODE_9) {//只处理数字                    if (result.size() &lt; pswLength) {                        result.add(keyCode - 7);                        invalidate();                        ensureFinishInput();                    }                    return true;                }                if (keyCode == KeyEvent.KEYCODE_DEL) {                    if (!result.isEmpty()) {//不为空，删除最后一个                        saveResult = result.size();                        result.remove(result.size() - 1);                        invalidate();                    }                    return true;                }                if (keyCode == KeyEvent.KEYCODE_ENTER) {                    ensureFinishInput();                    return true;                }            }            return false;        }</code></pre><p>说明一下只处理数字那部分，为什么是keyCode - 7，我们点进源码看看<br><img src="/images/pswTextKeyCode.png" alt=""><br>可以看出，我们用keyCode - 7就刚好等于输入的数字<br>最终效果：<br><img src="/images/PswGif.gif" alt=""></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>以上就是该自定义view的全部说明，并未贴出全部的完整代码，如有需要可到<a href="https://github.com/rokudol/PswText.git" target="_blank" rel="noopener">GitHub</a>查看完整源码，如果喜欢或觉得该控件对你有帮助还请点个star，文中如有错误还请指出，谢谢</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我司之前有个需求，要求类似支付宝那样的密码支付，产品要求输入的当前字符需要是明文密码，1s后转换为圆点，原本想网上那么多密码输入框，肯定没问题，结果UI一出图就懵逼了，翻遍了各个角落，都找不到类似的密码输入框，没办法，自己写吧。&lt;br&gt;使用方法，在gradle中添加：compile ‘com.rokudoll:PswText:1.0.0’即可使用&lt;br&gt;当然绘制思路参照了其他大佬的思路，言归正传，先来看看效果图：&lt;br&gt;&lt;img src=&quot;/images/Renderings.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="自定义View" scheme="http://blog.rokudol.cn/categories/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
    
      <category term="Android" scheme="http://blog.rokudol.cn/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>RecyclerView的基本使用与进阶（二）</title>
    <link href="http://blog.rokudol.cn/RecyclerView%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E4%B8%8E%E8%BF%9B%E9%98%B6%EF%BC%88%E4%BA%8C%EF%BC%89.html"/>
    <id>http://blog.rokudol.cn/RecyclerView的基本使用与进阶（二）.html</id>
    <published>2017-05-27T07:05:12.000Z</published>
    <updated>2018-04-07T02:37:46.199Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://blog.rokudol.cn/RecyclewView%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E4%B8%8E%E8%BF%9B%E9%98%B6-%E4%B8%80.html">上一篇</a>讲了RecyclerView最基本的使用，那点东西是不足以用到实际开发中的，一般在实际开发的时候，我们都会为每个item添加一条分割线，那么这篇文章就讲讲添加分割线的几种方式以及如何定制分割线，来画出酷炫的分割线<br><a id="more"></a></p><h2 id="利用背景颜色来绘制简单分割线："><a href="#利用背景颜色来绘制简单分割线：" class="headerlink" title="利用背景颜色来绘制简单分割线："></a>利用背景颜色来绘制简单分割线：</h2><p>比如我们将RecyclerView的背景颜色设置为黑色,然后在adapter中的onBindViewHodler给item设置margin就能达到分割线的效果：</p><pre><code>RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) holder.itemView.getLayoutParams();        params.topMargin = 2;        holder.itemView.setLayoutParams(params);</code></pre><p><img src="/images/recyclerviewitem1.png" alt=""></p><p>或者利用ItemDicoration实现分割线，但其实也是利用背景颜色：<br>新建类继承自ItemDicoration，覆写getItemOffsets()</p><pre><code>public class MyDividerItemDecoration extends RecyclerView.ItemDecoration {    @Override    public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) {        super.getItemOffsets(outRect, view, parent, state);        if (parent.getChildAdapterPosition(view) != 0) {            outRect.top = 1;        }    }}</code></pre><p>先判断是否是第一个item，如果是则不设置margin,然后我们在activity添加上</p><pre><code>rv.addItemDecoration(new MyDividerItemDecoration());</code></pre><p>当然，还有一个更简单的方式，官方为我们提供了添加分割线的方法，只需要在activity中添加如下代码：</p><pre><code>rv.addItemDecoration(new DividerItemDecoration(this,DividerItemDecoration.VERTICAL));</code></pre><p>效果都是一样的，不过官方为我们提供的分割线可以更优雅的自定义分割线的样式<br>在drawable中新建一个xml<br>类型设置为shape:</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;       android:shape=&quot;rectangle&quot;&gt;    &lt;gradient        android:centerColor=&quot;@color/colorPrimary&quot;        android:endColor=&quot;@color/colorPrimary&quot;        android:startColor=&quot;@color/colorPrimary&quot;        android:type=&quot;linear&quot;/&gt;    &lt;size android:height=&quot;2dp&quot;/&gt;&lt;/shape&gt;</code></pre><p>参数名称就不用解释了，看名字就知道啥意思，然后在当前APP引用的style中添加如下属性</p><pre><code>&lt;item name=&quot;android:listDivider&quot;&gt;@drawable/divider&lt;/item&gt;</code></pre><p>然后就大功告成了，效果图不贴了，有兴趣自己去试试吧<br>既然已经引出了ItemDecoration，那么就要好好介绍一下该类<br>官方的介绍是：An ItemDecoration allows the application to add a special drawing and layout offset to specific item views from the adapter’s data set. This can be useful for drawing dividers between items, highlights, visual grouping boundaries and more.<br>简单翻译一下，允许adapter设置特定的视图或偏移量。就是说可以自定义偏移量甚至是视图<br>那么我们来给每个item左边画个圆<br>既然要在画布上画某个东西，那么就一定需要画笔</p><pre><code>private Paint mPaint;</code></pre><p>然后覆写onDraw方法,既然我们要给每一个item左边绘制一个圆，那么就要获取到每一个item</p><pre><code>@Override    public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) {        super.onDraw(c, parent, state);        int childCount = parent.getChildCount();        for (int i = 0; i &lt;childCount; i++) {            View view = parent.getChildAt(i);            int index = parent.getChildAdapterPosition(view);        }    }</code></pre><p>这样就获取到了每一个item，画圆就需要用canvas.drawCircle，其中有四个参数，分别是：<br>float cx:圆心的x轴坐标<br>float cy:圆心的y轴坐标<br>float radius: 圆的半径<br>Paint paint:这个就不解释了<br>那么来看看圆心的x轴坐标怎么计算：<br>首先，我们是将圆绘制在左边，那么我们就需要获取到左边的大小<br>即：<br><code>float left = view.getLeft()</code><br>圆心的x轴左边就是</p><pre><code>float cx = left / 2;</code></pre><p>再来计算y轴坐标：<br>y轴坐标计算相比之下就比较复杂一点，y轴圆心必定是在高的中间，所以我们需要获取到top和bottom</p><pre><code>float top = view.getTop();float bottom = view.getBottom();float cy = top + (bottom - top) / 2;</code></pre><p>来看看效果<br><img src="/images/recyclerviewdivider1.png" alt=""><br>附上完整代码:</p><pre><code>public class MyDividerItemDecoration extends RecyclerView.ItemDecoration {    private Paint mPaint;    private float mOffsetLeft;//距离左边的偏移量    private float mOffsetTop;//距离顶端的偏移量    private float radius;//圆的半径public MyDividerItemDecoration(Context context) {    mPaint = new Paint();    mPaint.setAntiAlias(true);    mPaint.setColor(Color.BLACK);    mOffsetLeft = context.getResources().getDimension(R.dimen.offSetLeft);    radius = context.getResources().getDimension(R.dimen.radius);}@Overridepublic void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) {    super.getItemOffsets(outRect, view, parent, state);    if (parent.getChildAdapterPosition(view) != 0) {        mOffsetTop = 1;        outRect.top = 1;    }    outRect.left = (int) mOffsetLeft;}@Overridepublic void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) {    super.onDraw(c, parent, state);    int childCount = parent.getChildCount();    for (int i = 0; i &lt; childCount; i++) {        View view = parent.getChildAt(i);        int index = parent.getChildAdapterPosition(view);        float left = view.getLeft();        float bottom = view.getBottom();        float top = view.getTop();        if (i == 0) {            top = mOffsetTop;        }        float cx = left / 2;        float cy = top + (bottom - top) / 2;        c.drawCircle(cx,cy,radius,mPaint);    }}</code></pre><p>以上就是分割线的绘制及简单的itemDecoration的使用，如有错误，还请指出</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://blog.rokudol.cn/RecyclewView%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E4%B8%8E%E8%BF%9B%E9%98%B6-%E4%B8%80.html&quot;&gt;上一篇&lt;/a&gt;讲了RecyclerView最基本的使用，那点东西是不足以用到实际开发中的，一般在实际开发的时候，我们都会为每个item添加一条分割线，那么这篇文章就讲讲添加分割线的几种方式以及如何定制分割线，来画出酷炫的分割线&lt;br&gt;
    
    </summary>
    
      <category term="RecyclerView" scheme="http://blog.rokudol.cn/categories/RecyclerView/"/>
    
    
      <category term="Android" scheme="http://blog.rokudol.cn/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>RecyclewView的基本使用与进阶(一)</title>
    <link href="http://blog.rokudol.cn/RecyclewView%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E4%B8%8E%E8%BF%9B%E9%98%B6%EF%BC%88%E4%B8%80%EF%BC%89%E4%B8%80.html"/>
    <id>http://blog.rokudol.cn/RecyclewView的基本使用与进阶（一）一.html</id>
    <published>2017-05-26T09:05:10.000Z</published>
    <updated>2018-04-07T02:37:46.200Z</updated>
    
    <content type="html"><![CDATA[<p>最近打算把RecyclerView重新整理一下，从最基础的使用到各种定制化的进阶使用，开一个小系列，本系列不讲源码，只讲如何使用，如果有什么问题请指出<br>本系列打算整理以下使用方法：<br><a href="http://blog.rokudol.cn/RecyclewView%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E4%B8%8E%E8%BF%9B%E9%98%B6-%E4%B8%80.html">1、RecyclerView的简单使用</a><br>2、RecyclerView添加分割线，定制分割线<br>3、RecyclerView添加item动画<br>4、RecyclerView复杂布局<br>5…(想到再加)<br><a id="more"></a></p><h1 id="RecyclerView的简单使用"><a href="#RecyclerView的简单使用" class="headerlink" title="RecyclerView的简单使用"></a>RecyclerView的简单使用</h1><p>其实跟ListView使用步骤一样，只是有些细微的不同，先来张效果图<br><img src="/images/recyclerview.gif" alt=""><br>那么接下来就开始本篇博客的正文，如何使用RecyclerView，步骤如下：</p><h2 id="首先依赖RecyclerView"><a href="#首先依赖RecyclerView" class="headerlink" title="首先依赖RecyclerView"></a>首先依赖RecyclerView</h2><p>在module的build.gradle中添加依赖：</p><pre><code>compile &apos;com.android.support:recyclerview-v7:25.3.1&apos;</code></pre><h2 id="使用RecyclerView"><a href="#使用RecyclerView" class="headerlink" title="使用RecyclerView"></a>使用RecyclerView</h2><p>完成依赖后，自然在是Activity的布局文件中使用RecyclerView：</p><pre><code>&lt;android.support.v7.widget.RecyclerView        android:id=&quot;@+id/rv&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;/&gt;</code></pre><p>再去Activity中绑定Id</p><pre><code>rv = (RecyclerView) findViewById(R.id.rv);</code></pre><h2 id="写Adapter"><a href="#写Adapter" class="headerlink" title="写Adapter"></a>写Adapter</h2><p>接下来就是写Adapter了，与ListView不同的是，RecyclerView必须要写ViewHolder</p><pre><code>public class RvAdapter extends RecyclerView.Adapter&lt;RvAdapter.RvHolder&gt; {    private List&lt;Integer&gt; list;public RvAdapter(List list) {    this.list = list;}@Overridepublic RvHolder onCreateViewHolder(ViewGroup parent, int viewType) {    View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.rv_item, parent, false);    return new RvHolder(view);}@Overridepublic void onBindViewHolder(RvHolder holder, int position) {    holder.img.setBackgroundResource(list.get(position));}@Overridepublic int getItemCount() {    return list.size();}class RvHolder extends RecyclerView.ViewHolder {    ImageView img;public RvHolder(View itemView) {    super(itemView);    img = (ImageView) itemView.findViewById(R.id.img);}}}</code></pre><p>item的布局也很简单</p><pre><code>&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;              android:layout_width=&quot;match_parent&quot;              android:layout_height=&quot;wrap_content&quot;              android:orientation=&quot;vertical&quot;&gt;&lt;ImageView    android:id=&quot;@+id/img&quot;    android:layout_width=&quot;100dp&quot;    android:layout_height=&quot;wrap_content&quot;    android:layout_gravity=&quot;center&quot;    android:layout_marginBottom=&quot;10dp&quot;/&gt;&lt;/LinearLayout&gt;</code></pre><h2 id="传递数据并设置RecyclerView的LayoutManager"><a href="#传递数据并设置RecyclerView的LayoutManager" class="headerlink" title="传递数据并设置RecyclerView的LayoutManager"></a>传递数据并设置RecyclerView的LayoutManager</h2><p>最后我们在Activity中将数据传到adapter中</p><pre><code>public class MainActivity extends AppCompatActivity {    private RecyclerView rv;    private List&lt;Integer&gt; list;    private RvAdapter adapter;@Overrideprotected void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_main);    rv = (RecyclerView) findViewById(R.id.rv);    list = new ArrayList&lt;&gt;();    for (int i = 0; i &lt; 3; i++) {        list.add(R.mipmap.p1);        list.add(R.mipmap.p2);        list.add(R.mipmap.p3);        list.add(R.mipmap.p4);        list.add(R.mipmap.p5);        list.add(R.mipmap.p6);    }    adapter = new RvAdapter(list);    rv.setLayoutManager(new LinearLayoutManager(this));    rv.setAdapter(adapter);}}</code></pre><p>这样就大功告成了，来看看效果:<br><img src="/images/recyclerview_linear.png" alt=""></p><h2 id="GridLayout"><a href="#GridLayout" class="headerlink" title="GridLayout"></a>GridLayout</h2><p>接下来看看RecyclerView的强大之处，如果我们想要GridView的效果怎么办？重写？no no no no，只需要修改一句代码即可，就是我们的LayoutManager：</p><pre><code>rv.setLayoutManager(new GridLayoutManager(this,2));</code></pre><p>来看看效果：<br><img src="/images/recyclerviewgrid.png" alt=""></p><h2 id="瀑布流"><a href="#瀑布流" class="headerlink" title="瀑布流"></a>瀑布流</h2><p>瀑布流实现也非常的简单,同样是更改LayoutManager：</p><pre><code>rv.setLayoutManager(new StaggeredGridLayoutManager(2,StaggeredGridLayoutManager.VERTICAL));</code></pre><p>先来看看效果：<br><img src="/images/recyclerviewstagger1.png" alt=""><br>咋跟Grid一样的效果？？<br>不急，先理清思路，实现瀑布流关键就在于那个不同的高度，既然这样，就直接给每个item设置不同的高度就行了，那么就去adapter中去设置随机高度：</p><pre><code>private void randomHeight(List&lt;Integer&gt; list){           heights = new ArrayList&lt;&gt;();           for (int i = 0; i &lt;list.size() ; i++) {               heights.add((int) (300+Math.random()*300));           }       }</code></pre><p>然后在onBindViewHolder中给每个item设置随机高度：</p><pre><code>RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) holder.itemView.getLayoutParams();    params.height = heights.get(position);    holder.itemView.setLayoutParams(params);</code></pre><p>最后来看看效果：<br>    <img src="/images/recyclerviewstagger.png" alt=""><br>    虽然比较简陋，也算是一个简单的瀑布流，各位根据自己的需求更改吧，下一篇讲讲分割线的绘制</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近打算把RecyclerView重新整理一下，从最基础的使用到各种定制化的进阶使用，开一个小系列，本系列不讲源码，只讲如何使用，如果有什么问题请指出&lt;br&gt;本系列打算整理以下使用方法：&lt;br&gt;&lt;a href=&quot;http://blog.rokudol.cn/RecyclewView%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E4%B8%8E%E8%BF%9B%E9%98%B6-%E4%B8%80.html&quot;&gt;1、RecyclerView的简单使用&lt;/a&gt;&lt;br&gt;2、RecyclerView添加分割线，定制分割线&lt;br&gt;3、RecyclerView添加item动画&lt;br&gt;4、RecyclerView复杂布局&lt;br&gt;5…(想到再加)&lt;br&gt;
    
    </summary>
    
      <category term="RecyclerView" scheme="http://blog.rokudol.cn/categories/RecyclerView/"/>
    
    
      <category term="Android" scheme="http://blog.rokudol.cn/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>DialogFragment与Fragment之间互相传值</title>
    <link href="http://blog.rokudol.cn/DialogFragment%E4%B8%8EFragment%E4%B9%8B%E9%97%B4%E4%BA%92%E7%9B%B8%E4%BC%A0%E5%80%BC.html"/>
    <id>http://blog.rokudol.cn/DialogFragment与Fragment之间互相传值.html</id>
    <published>2017-05-20T11:08:45.000Z</published>
    <updated>2018-04-07T02:37:46.199Z</updated>
    
    <content type="html"><![CDATA[<p>DialogFragment与Fragment互相传值有两种情况：</p><h1 id="一、DialogFragment与Fragment在同一Activity"><a href="#一、DialogFragment与Fragment在同一Activity" class="headerlink" title="一、DialogFragment与Fragment在同一Activity"></a>一、DialogFragment与Fragment在同一Activity</h1><p>在这种情况下，就利用onActivityResult来取值，与Activity获取另一个Activity的返回值一样，首先定义一个REQUEST的静态常量：</p><pre><code>public static final int REQUEST=1;</code></pre><p>然后在需要取值的Fragemnt中，覆写onActivityResult：</p><pre><code>@Override                 public void onActivityResult(int requestCode,int resultCode,Intent data){                      super.onActivityResult(requestCode,resultCode,data);                      if(requestCode == REQUEST){                           //data.getStringExtra就获取到了DialogFragment所传递过来的值                           String evaluate = data.getStringExtra(DialogFragment.RESPONSE};            }  </code></pre><a id="more"></a><p>接下来是DialogFragment：<br>同样的，需要先定义一个RESPONSE;</p><pre><code>public static final String RESPONSE=&quot;response&quot;;</code></pre><p>至于为什么是String而不是int，boolean类型的，只是因为，这个RESPONSE只是一个键名，<br>就跟Intent的put，get方法一样，需要同一个键才能获取到相应的值，接下来就是写一个方法，用来传递给Fragment</p><pre><code>protected void setResult(){                    //先判断是否有targetFragment                    if(getTargetFragment == null){                         return;                    }else{                         Intent intent = new Intent();                         intent.putExtra(RESPONSE,&quot;需要传递的值&quot;);                         getTragetFragment.onActivityResult(Fragment.REQUEST,Acitivity.RESULT.OK,intent);                    }              }  </code></pre><p> 那么，在Fragment中显示DialogFragment之前，需要先添加targetFragment才行，<br>否则在DialogFragment中无法找到targetFragment,就无法执行存值的逻辑</p><pre><code>DialogFragment dialog = new DialogFragment();                  dialog.setTragetFragment(Fragment.this,REQUEST);                  dialog.show(getFragmentManager,&quot;dialog&quot;);  </code></pre><p>`这样，DialogFragment传值给Fragment就完成了，Fragment传值给DialogFragment也是同理</p><h1 id="二、DialogFragment与Fragment不在同一Activity"><a href="#二、DialogFragment与Fragment不在同一Activity" class="headerlink" title="二、DialogFragment与Fragment不在同一Activity"></a>二、DialogFragment与Fragment不在同一Activity</h1><p> 与两个Activity之间传值一样，使用Intent传值，在AFrament中传值给BFragment：</p><pre><code>Intent intent = new Intent(getActivity,BFragment.class);     intent.putExtra(BFragment.EXTRA_STRING,&quot;需要传递的值&quot;);     startActivity(intent);  </code></pre><p>值已经传递给BFragment了，接下来是在BFragment中取值：</p><pre><code>String data = getActivity.getIntent().getString Extra(EXTRA_STRING);  </code></pre><p>以上就是DialogFragment与Fragment之间互相传值的方法，若文章中有什么差错还请各位指出，谢谢</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;DialogFragment与Fragment互相传值有两种情况：&lt;/p&gt;
&lt;h1 id=&quot;一、DialogFragment与Fragment在同一Activity&quot;&gt;&lt;a href=&quot;#一、DialogFragment与Fragment在同一Activity&quot; class=&quot;headerlink&quot; title=&quot;一、DialogFragment与Fragment在同一Activity&quot;&gt;&lt;/a&gt;一、DialogFragment与Fragment在同一Activity&lt;/h1&gt;&lt;p&gt;在这种情况下，就利用onActivityResult来取值，与Activity获取另一个Activity的返回值一样，首先定义一个REQUEST的静态常量：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static final int REQUEST=1;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后在需要取值的Fragemnt中，覆写onActivityResult：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override  
               public void onActivityResult(int requestCode,int resultCode,Intent data){  
                    super.onActivityResult(requestCode,resultCode,data);  
                    if(requestCode == REQUEST){  
                         //data.getStringExtra就获取到了DialogFragment所传递过来的值  
                         String evaluate = data.getStringExtra(DialogFragment.RESPONSE};  
          }  
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Android" scheme="http://blog.rokudol.cn/categories/Android/"/>
    
    
      <category term="Android" scheme="http://blog.rokudol.cn/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>MVP+Retrofit+RxJava+ButterKnife的简单使用</title>
    <link href="http://blog.rokudol.cn/MVP+Retrofit+RxJava+ButterKnife%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8.html"/>
    <id>http://blog.rokudol.cn/MVP+Retrofit+RxJava+ButterKnife的简单使用.html</id>
    <published>2017-05-20T01:17:39.000Z</published>
    <updated>2018-04-07T02:37:46.199Z</updated>
    
    <content type="html"><![CDATA[<p>最近学习了挺多东西，所以想写个demo把最近所学的全都用到，于是就有了这篇博客，这个demo实现的功能特别简单，就是一个查询天气，并且放到textview及recyclerview上显示出来，用的mvp设计框架，也是这两天才稍微看懂的东西，如果有错，还请各路大佬指出，那么废话不多说，先上效果图<br><img src="/images/MVP.gif" alt=""><br><a id="more"></a></p><h1 id="确定功能或需求"><a href="#确定功能或需求" class="headerlink" title="确定功能或需求"></a>确定功能或需求</h1><p>  从图中能看出有以下功能：</p><ol><li>显示progress</li><li>隐藏progress</li><li>请求数据成功或失败弹出toast提示</li><li>将获取到的数据设置到TextView上</li><li>将获取到的数据设置到recyclerview上</li><li>如果查询出错清空所有的数据<h1 id="确定V层接口"><a href="#确定V层接口" class="headerlink" title="确定V层接口"></a>确定V层接口</h1>确定了功能那么就是如何实现了，根据mvp的思想，V层只负责初始化view，并将view层接收到的数据（即EditText等）传递到P层，P层再传递给M层，让M层操作数据，包括存储和耗时操作等，然后M层再将数据传回给P层，P层来更新UI，说得再明白点，mvp就是面向接口，那么m,v,p层的接口该怎么写呢？很简单，根据上面我们列出的功能来写相应的接口，直接来看代码：</li></ol><pre><code>  public interface IMainActivity {      //显示progress      void showProgress();   //隐藏progress      void hideProgress();      /*     * 设置文本     * @param temperaturestr:今日温度,@param  coldstr:今日建议,@param citystr:城市     * @param yesterdayflstr：昨日风力,@param yesterdayfxstr：昨日风向,@param yesterdayhighstr：昨日最高温     * @param yesterdaylowstr：昨日最低温,@param yesterdaytypestr：昨日天气类型,@param yesterdaydatestr：昨日时间     *     * */      void setText(String temperaturestr, String coldstr, String citystr, String yesterdayflstr,                   String yesterdayfxstr, String yesterdayhighstr, String yesterdaylowstr,                   String yesterdaytypestr, String yesterdaydatestr);  //设置item  void setItem(MyAdapter adapter);  //Toast提示  void showMsg(String msg);  //输入错误时清空textview,recyclerview的item  void clearAll();  }  </code></pre><h1 id="V层代码具体实现"><a href="#V层代码具体实现" class="headerlink" title="V层代码具体实现"></a>V层代码具体实现</h1><p>那么现在V层，也就是Activity只需要实现这个接口即可，看代码：</p><pre><code>public class MainActivity extends Activity implements IMainActivity {  @BindView(R.id.temperature)  TextView temperature;  @BindView(R.id.rv)  RecyclerView rv;  @BindView(R.id.citykey)  EditText citykey;  @BindView(R.id.query)  Button query;  @BindView(R.id.progress)  ProgressBar progress;  private WeatherPresenter weatherPresenter;  //初始化控件，并new出P层实例  @Override  protected void onCreate(Bundle savedInstanceState) {      super.onCreate(savedInstanceState);      setContentView(R.layout.activity_main);      ButterKnife.bind(this);      weatherPresenter = new WeatherPresenter(this);  }  //点击监听，用P层实例去调用请求数据的接口  @OnClick(R.id.query)  void query() {      if (citykey.getText().toString().equals(&quot;&quot;)) {          citykey.setError(&quot;不能为空&quot;);      }      weatherPresenter.validateCredentials(citykey.getText().toString());  }  @Override  public void showProgress() {      progress.setVisibility(View.VISIBLE);  }  @Override  public void hideProgress() {      progress.setVisibility(View.GONE);  }  @Override  public void setText(String temperaturestr, String coldstr, String citystr, String yesterdayflstr,                      String yesterdayfxstr, String yesterdayhighstr, String yesterdaylowstr,                      String yesterdaytypestr, String yesterdaydatestr) {      temperature.setText(&quot;城市：&quot; + citystr + &quot;\n&quot; +              &quot;今日温度：&quot; + temperaturestr + &quot;\n&quot; +              &quot;今日建议：&quot; + coldstr + &quot;\n&quot; +              &quot;昨日时间：&quot; + yesterdaydatestr + &quot;\n&quot; +              &quot;昨日天气：&quot; + yesterdaytypestr + &quot;\n&quot; +              &quot;昨日最&quot; + yesterdayhighstr + &quot;\n&quot; +              &quot;昨日最&quot; + yesterdaylowstr + &quot;\n&quot; +              &quot;昨日风力：&quot; + yesterdayflstr + &quot;\n&quot; +              &quot;昨日风向：&quot; + yesterdayfxstr      );  }  //设置适配器，显示recyclerview，adapter由P层传回  @Override  public void setItem(MyAdapter adapter) {      rv.setLayoutManager(new LinearLayoutManager(this));      rv.setAdapter(adapter);  }  @Override  public void showMsg(String msg) {      Toast.makeText(this, msg, Toast.LENGTH_SHORT).show();  }  @Override  public void clearAll() {      rv.setAdapter(null);      temperature.setText(&quot;&quot;);  }  </code></pre><h1 id="确定P层接口和具体实现"><a href="#确定P层接口和具体实现" class="headerlink" title="确定P层接口和具体实现"></a>确定P层接口和具体实现</h1><p>这里注意一下，我在onCreate方法中实例化了P层，原因就是要让P层拿到V层的实例，这样才能让P层去操作UI，那么P层需要做哪些操作呢，前面说了，M层去操作数据，P层操作UI，再看看我们的效果图，V层获取到了EditText输入的字符串，并且点击查询后获取到了相应的数据，现在要做的，就是把V层获取到的数据传递给M层，让M层去做耗时操作，但是MVP模式，V层是不能直接跟M层进行交互的，怎么办？很简单，我们还有P层没用到，P层的作用就是V层和M层的桥梁，让V层把数据通过P层传递给M层即可，具体怎么做？我们再来分析一下，V层需要传递数据给M层，那么P层就需要一个方法，来接收V层的数据，这个方法就是点击查询按钮后要执行的方法，那么P层现在要做的工作就很简单了<br>let me show you code：</p><pre><code>public interface IWeatherPresenter {  //请求数据  void validateCredentials(String citykey);  </code></pre><p>}  </p><p>接下来在定义一个类去实现该接口</p><pre><code>//进行数据请求，请求时显示progress  @Override  public void validateCredentials(String citykey) {      view.showProgress();      model.getWeather(citykey, this);  }  </code></pre><h1 id="确定M层接口及M层的具体实现"><a href="#确定M层接口及M层的具体实现" class="headerlink" title="确定M层接口及M层的具体实现"></a>确定M层接口及M层的具体实现</h1><p>有同学就要问了，model.getWeather又是从哪里来的方法，都是什么鬼，不要急，前面说了，P层需要一个方法来接收V层传递过来数据，然后才能让P层把数据传递给M层，那model.getWeather肯定就是M层的方法了，没错，M层需要做耗时操作，而具体要查询哪一个城市的天气数据，就是从V层传递过来的，逻辑是不是一下就通了，再来分析下M层，M层需要的就是耗时操作，那么耗时操作就有两种可能：<br>1、请求成功<br>2、请求失败<br>所以我们M层的接口写成这样：</p><pre><code>public interface IWeatherModel {      interface OnLinstener {          //请求失败          void onFailed();          //请求成功          void onSuccess();      }      //请求数据      void getWeather(String citykey, OnLinstener linstener);  }  </code></pre><p>现在万事具备，就剩个M层的类来实现这个接口就行了，但是，先暂停一下，看看我们的标题，基于retrofit+rxjava，前面一直没用，当然就是在这个时候来用的，先给个完整的<a href="http://wthrcdn.etouch.cn/weather_mini?citykey=101010100" target="_blank" rel="noopener">URL</a>，现在来看看retrofit用来实现get请求的接口：</p><pre><code>public interface APIService {      @GET(&quot;/weather_mini&quot;)      Observable&lt;Bean&gt; getApi(@Query(&quot;citykey&quot;) String citykey);  }  </code></pre><h1 id="RxJava的简单使用"><a href="#RxJava的简单使用" class="headerlink" title="RxJava的简单使用"></a>RxJava的简单使用</h1><p>有同学要问，返回的Observable是个啥，这个是rxjava特有的，我能力不足，只限于能用的阶段。。还不能很好的解释其中的原理，有兴趣的可以去看看<a href="http://www.jianshu.com/u/c50b715ccaeb" target="_blank" rel="noopener">这位大佬rxjava的系列文章</a>，接下来是用于解析json的bean类，太长就不放了。。有兴趣可以下载源码看看，现在，要开始写M层的逻辑了，M层就是用来操作数据的，说白了就是耗时操作，存储数据，看代码：</p><pre><code>public class WeatherModel implements IWeatherModel {      private static final String TAG = &quot;WeatherModel&quot;;      private Retrofit retrofit;      private OkHttpClient client;      private MyBean bean;      //进行耗时操作，访问数据      @Override      public void getWeather(String citykey, final OnLinstener linstener) {          Interceptor interceptor = new Interceptor() {              @Override              public Response intercept(Chain chain) throws IOException {                  Request request = chain.request().newBuilder().build();                  return chain.proceed(request);              }          };          client = new OkHttpClient.Builder().addInterceptor(interceptor).build();          retrofit = new Retrofit.Builder()                  .baseUrl(&quot;http://wthrcdn.etouch.cn&quot;)                  .addCallAdapterFactory(RxJava2CallAdapterFactory.create())                  .addConverterFactory(GsonConverterFactory.create())                  .client(client)                  .build();          APIService api = retrofit.create(APIService.class);          api.getApi(citykey)                  .subscribeOn(Schedulers.io())//在io线程执行                  .observeOn(AndroidSchedulers.mainThread())//执行完成后回调给UI线程                  .subscribe(new Observer&lt;Bean&gt;() {                      @Override                      public void onSubscribe(Disposable d) {                          Log.i(TAG, &quot;onSubscribe: &quot;);                      }                      @Override                      public void onNext(Bean value) {                          if (value.getDesc().equals(&quot;OK&quot;)) {                              bean = new MyBean();                              bean.setWendu(value.getData().getWendu());                              bean.setGanmao(value.getData().getGanmao());                              bean.setCity(value.getData().getCity());                              bean.setYesterdayfl(value.getData().getYesterday().getFl());                              bean.setYesterdayfx(value.getData().getYesterday().getFx());                              bean.setYesterdayhigh(value.getData().getYesterday().getHigh());                              bean.setYesterdaylow(value.getData().getYesterday().getLow());                              bean.setYesterdaytype(value.getData().getYesterday().getType());                              bean.setYesterdaydate(value.getData().getYesterday().getDate());                              bean.setList(value.getData().getForecast());                              bean.setMsg(&quot;请求数据正确，请稍后&quot;);                              linstener.onSuccess();                              Log.i(TAG, &quot;onNext: &quot;);                          } else {                              bean = new MyBean();                              bean.setMsg(&quot;请求数据错误，请重新输入&quot;);                              linstener.onFailed();                          }                      }                      @Override                      public void onError(Throwable e) {                          linstener.onFailed();                          Log.e(TAG, &quot;onError: &quot;);                      }                      @Override                      public void onComplete() {                          Log.i(TAG, &quot;onComplete: &quot;);                      }                  });      }  </code></pre><h1 id="完整的M层代码"><a href="#完整的M层代码" class="headerlink" title="完整的M层代码"></a>完整的M层代码</h1><p>我写了另一个bean类来存储所有数据，这样P层才能直接把数据拿来用，但是在M层存储好说，怎么在P层取出来呢，如果两个类持有的不是同一个对象，那P层肯定是取不出数据的，很简单，有什么需求就写什么接口，P层需要M层存储的bean类，那么我们在M层的接口再写个getBean的方法，然后让M层去实现不就行了，P层拿到M层的实例直接调用方法就可以拿到我们想要的bean类了，所以完整的M层接口代码：</p><pre><code>public interface IWeatherModel {      interface OnLinstener {          //请求失败          void onFailed();          //请求成功          void onSuccess();      }      //请求数据      void getWeather(String citykey, OnLinstener linstener);      //获取bean类      MyBean getBean();  }  </code></pre><p>完整的M层代码：</p><pre><code>public class WeatherModel implements IWeatherModel {      private static final String TAG = &quot;WeatherModel&quot;;      private Retrofit retrofit;      private OkHttpClient client;      private MyBean bean;      //进行耗时操作，访问数据      @Override      public void getWeather(String citykey, final OnLinstener linstener) {          Interceptor interceptor = new Interceptor() {              @Override              public Response intercept(Chain chain) throws IOException {                  Request request = chain.request().newBuilder().build();                  return chain.proceed(request);              }          };          client = new OkHttpClient.Builder().addInterceptor(interceptor).build();          retrofit = new Retrofit.Builder()                  .baseUrl(&quot;http://wthrcdn.etouch.cn&quot;)                  .addCallAdapterFactory(RxJava2CallAdapterFactory.create())                  .addConverterFactory(GsonConverterFactory.create())                  .client(client)                  .build();          APIService api = retrofit.create(APIService.class);          api.getApi(citykey)                  .subscribeOn(Schedulers.io())//在io线程执行                  .observeOn(AndroidSchedulers.mainThread())//执行完成后回调给UI线程                  .subscribe(new Observer&lt;Bean&gt;() {                      @Override                      public void onSubscribe(Disposable d) {                          Log.i(TAG, &quot;onSubscribe: &quot;);                      }                      @Override                      public void onNext(Bean value) {                          if (value.getDesc().equals(&quot;OK&quot;)) {                              bean = new MyBean();                              bean.setWendu(value.getData().getWendu());                              bean.setGanmao(value.getData().getGanmao());                              bean.setCity(value.getData().getCity());                              bean.setYesterdayfl(value.getData().getYesterday().getFl());                              bean.setYesterdayfx(value.getData().getYesterday().getFx());                              bean.setYesterdayhigh(value.getData().getYesterday().getHigh());                              bean.setYesterdaylow(value.getData().getYesterday().getLow());                              bean.setYesterdaytype(value.getData().getYesterday().getType());                              bean.setYesterdaydate(value.getData().getYesterday().getDate());                              bean.setList(value.getData().getForecast());                              bean.setMsg(&quot;请求数据正确，请稍后&quot;);                              linstener.onSuccess();                              Log.i(TAG, &quot;onNext: &quot;);                          } else {                              bean = new MyBean();                              bean.setMsg(&quot;请求数据错误，请重新输入&quot;);                              linstener.onFailed();                          }                      }                      @Override                      public void onError(Throwable e) {                          linstener.onFailed();                          Log.e(TAG, &quot;onError: &quot;);                      }                      @Override                      public void onComplete() {                          Log.i(TAG, &quot;onComplete: &quot;);                      }                  });      }      //将保存的MyBean类返回给P层      @Override      public MyBean getBean() {          return this.bean;      }  }  </code></pre><h1 id="P层完整的代码"><a href="#P层完整的代码" class="headerlink" title="P层完整的代码"></a>P层完整的代码</h1><p>  P层完整的代码：</p><pre><code>public class WeatherPresenter implements IWeatherPresenter, IWeatherModel.OnLinstener {      private IMainActivity view;      private IWeatherModel model;      private List&lt;Bean.Data.forecast&gt; list;      //构造器，需要传入v层实例，并new一个m层实例，以达到让P层实现桥梁的作用      public WeatherPresenter(IMainActivity view) {          this.view = view;          this.model = new WeatherModel();      }      //进行数据请求，请求时显示progress      @Override      public void validateCredentials(String citykey) {          view.showProgress();          model.getWeather(citykey, this);      }      //数据请求失败时隐藏progress      @Override      public void onFailed() {          view.clearAll();          MyBean bean = model.getBean();          view.showMsg(bean.getMsg());          view.hideProgress();      }      //数据请求成功后将数据显示在控件上,且在请求成功后隐藏progress      @Override      public void onSuccess() {          MyBean bean = model.getBean();          if (bean.getMsg().equals(&quot;请求数据正确，请稍后&quot;)) {              view.showMsg(bean.getMsg());              view.setText(bean.getWendu(), bean.getGanmao(), bean.getCity(), bean.getYesterdayfl(),                      bean.getYesterdayfx(), bean.getYesterdayhigh(), bean.getYesterdaylow(),                      bean.getYesterdaytype(), bean.getYesterdaydate());              list = bean.getList();              MyAdapter adapter = new MyAdapter((Context) view, list);              view.setItem(adapter);              view.hideProgress();          }      }  }  </code></pre><p>  recyclerview的adapter非常简单，就不贴出来了，有兴趣的话就下载源码自己看看吧，欢迎各位大佬提出建议<br>  <a href="https://github.com/rokudol/MVP_Demo" target="_blank" rel="noopener">demoGitHub地址</a><br><a href="http://download.csdn.net/download/a361200614/9766505" target="_blank" rel="noopener">demo的下载地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近学习了挺多东西，所以想写个demo把最近所学的全都用到，于是就有了这篇博客，这个demo实现的功能特别简单，就是一个查询天气，并且放到textview及recyclerview上显示出来，用的mvp设计框架，也是这两天才稍微看懂的东西，如果有错，还请各路大佬指出，那么废话不多说，先上效果图&lt;br&gt;&lt;img src=&quot;/images/MVP.gif&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://blog.rokudol.cn/categories/Android/"/>
    
    
      <category term="Android" scheme="http://blog.rokudol.cn/tags/Android/"/>
    
  </entry>
  
</feed>
